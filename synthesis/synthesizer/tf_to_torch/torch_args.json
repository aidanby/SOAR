{"calculate_gain": {"nonlinearity": ["leaky_relu", "relu", "tanh", "linear", "conv2d", null], "param": [null]}, "uniform_": {"tensor": [-0.1, 0, -0.05, -0.25, -0.08, 0.9, -0.5, 1.5, 1e-05, 1.8, -0.01, null, -4, -1.0], "a": [0.99999, 1, -0.07, 0.25, 0, -0.001, -0.003, 1.1, 0.5, 0.9, -0.5, 4, 2, 5, -0.01, 0.05, -0.1, 0.1, -0.2, 0.08, -0.05, 0.01, null, -1], "b": [0.1, 1, 0.07, 0.05, 1.1, 0.5, 0.2, 0.01, null, 0.003, 0.001]}, "normal_": {"tensor": [0, 1, 3, null], "mean": [0, 1, 0.2, 0.05, 0.3, 0.1, 4, 0.01, null, 0.02, 0.0001, 0.001, 0.0005], "std": [0.1, 0.03, 0.05, 1, 0.01, 1e-08, null, 0.02, 0.001]}, "constant_": {"tensor": [null], "val": [0, 1, 0.1, 0.2, 0.5, 2.0, "value", null, -1.0]}, "ones_": {"tensor": [null]}, "zeros_": {"tensor": [0, null]}, "eye_": {"tensor": [null]}, "dirac_": {"tensor": [null]}, "xavier_uniform_": {"tensor": [null], "gain": [0.1, 1, 1.414, 1.4, 4, 0.01, null]}, "relu": {"input": [0, 512, 3, null], "inplace": [0.1, true, 0, 0.05, 0.2, 64, 32, 512, 8, null]}, "linear": {"input": [0, 25088, 1000, 10, "linear", null], "weight": [0, 1, 2, 4096, 100, 1000, 500, null, "../github_crawler/torch_pyfiles", -1], "bias": [false, 1, 2, null, -1]}, "conv1d": {"input": [0, null], "weight": [0, 512, null], "bias": [0, true, null], "stride": [1, null], "padding": [0, "SAME", 3, "VALID", 81, null], "dilation": [0.0, 1, 243, null], "groups": [1, null]}, "xavier_normal_": {"tensor": [null], "gain": [0.1, 1, 1.414, null, 0.02]}, "kaiming_uniform_": {"tensor": [null], "a": [0, 1, null], "mode": ["fan_out", "fan_in", null], "nonlinearity": ["leaky_relu", "sigmoid", "relu", "linear", null]}, "kaiming_normal_": {"tensor": [null], "a": [0, 1, 0.1, 0.01, null, 0.02], "mode": ["fan_out", "fan_in", null], "nonlinearity": ["linear", "leaky_relu", "relu", null]}, "orthogonal_": {"tensor": [0, null], "gain": [1.0, 0.01, null]}, "sparse_": {"tensor": [null], "sparsity": [null], "std": [null]}, "conv2d": {"input": [0, 16, ["name", "\"conv\""], null], "weight": [32, 1, 64, 128, 0, 96, 2, 3, 256, 4096, 16, 512, null, 24, "../github_crawler/torch_pyfiles"], "bias": [0, 1, 2, 3, 4, 5, [3, 3], 9, "same", null, [1, 1]], "stride": [0, 1, 2, 4, null], "padding": [0, 1, "SAME", 3, [0, 0], 2, "valid", 4, "VALID", "same", null], "dilation": [1, "dim_inc_conv", "mix", "conv1", "loc_conv1", "dim_inc", null], "groups": [1, 2, "SAME", "VALID", null]}, "conv3d": {"input": [null], "weight": [0, null], "bias": [1, [1, 3, 3], null], "stride": [1, 3, null], "padding": [0, "same", "valid", null], "dilation": [3, null], "groups": [3, null]}, "conv_transpose1d": {"input": [0, null], "weight": [null], "bias": [null], "stride": [null], "padding": [0, null], "output_padding": [null], "groups": [], "dilation": []}, "max_pool2d": {"*args": [0, null], "**kwargs": [0, 1, 2, 3, 4, [2, 2], null, [1, 1]]}, "adaptive_avg_pool2d": {"input": [0, null], "output_size": [0, 1, [4, 4], null, [1, 1]]}, "avg_pool2d": {"input": [0, null], "kernel_size": [0, 1, 2, 3, 4, 5, 6, 7, 8, [2, 2], [4, 4], [7, 7], 16, null, 28, [1, 1]], "stride": [0, 1, 2, 3, 8, [2, 1], null], "padding": [0, 1, "SAME", [0, 0], 2, [3, 3], "VALID", null], "ceil_mode": [false, null], "count_include_pad": [false, true, null], "divisor_override": [1.0]}, "interpolate": {"input": [0, null], "size": [0, [224, 224], [256, 256], [299, 299], [298, 1], null], "scale_factor": [0, 0.25, 2, 0.5, 4, 0.125, 8, [2, 2], null], "mode": ["bicubic", "area", "bilinear", "linear", null, "nearest"], "align_corners": [false, true, null]}, "upsample": {"input": [0, -1, null], "size": [64, 0, [256, 256], [1024, 2048], [299, 299], [38, 38], null, [450, 450], [30, 30], [31, 31]], "scale_factor": [0, 2, 8, 16, null], "mode": ["trilinear", "nearest", "bilinear", null], "align_corners": [false, true, null]}, "conv_transpose2d": {"input": [null], "weight": [0, null], "bias": [0, null], "stride": [1, 2, null], "padding": [0, null], "output_padding": [0, null], "groups": [1, 2, null], "dilation": [1, null]}, "conv_transpose3d": {"input": [null], "weight": [null], "bias": [null], "stride": [null], "padding": [null], "output_padding": [], "groups": [3], "dilation": []}, "upsample_bilinear": {"input": [null], "size": [null], "scale_factor": [2]}, "upsample_nearest": {"input": [null], "size": [], "scale_factor": [2]}, "from_float": {"mod": [null]}, "unfold": {"input": [0, 1, 2, null], "kernel_size": [1, 2, 3, 100, [61, 61], null], "dilation": [1, null], "padding": [32, 0, null], "stride": [8, 1, 4, null]}, "fold": {"input": [0, 1, 2, 3, "./result/cur_lfw_result.mat", "value", null], "output_size": [1, 2, 3, 100, [61, 61], null, "../github_crawler/torch_pyfiles"], "kernel_size": [1, null], "dilation": [1, null], "padding": [0, 32, null], "stride": [8, true, 4, null]}, "avg_pool1d": {"input": [0, null], "kernel_size": [1, null], "stride": [null], "padding": [], "ceil_mode": [], "count_include_pad": []}, "avg_pool3d": {"input": [0, null], "kernel_size": [1, null], "stride": [2, null], "padding": [null, 7], "ceil_mode": [7], "count_include_pad": [null], "divisor_override": []}, "max_pool1d": {"*args": [0, null], "**kwargs": [1, 3, null]}, "max_pool3d": {"*args": [0, null], "**kwargs": [0, 1, [1, 1, 1]]}, "max_unpool1d": {"input": [], "indices": [], "kernel_size": [], "stride": [], "padding": [], "output_size": []}, "max_unpool2d": {"input": [null], "indices": [null], "kernel_size": [2], "stride": [2], "padding": [0], "output_size": [null]}, "max_unpool3d": {"input": [], "indices": [], "kernel_size": [], "stride": [], "padding": [], "output_size": []}, "lp_pool1d": {"input": [], "norm_type": [], "kernel_size": [], "stride": [], "ceil_mode": []}, "lp_pool2d": {"input": [null], "norm_type": [2, null], "kernel_size": [null], "stride": [null], "ceil_mode": []}, "adaptive_max_pool1d": {"*args": [0, null], "**kwargs": [1]}, "adaptive_max_pool2d": {"*args": [0, null], "**kwargs": [1, [1, 1], null]}, "adaptive_max_pool3d": {"*args": [0], "**kwargs": [1, [1, 1, 1]]}, "adaptive_avg_pool1d": {"input": [0, null], "output_size": [1, null]}, "adaptive_avg_pool3d": {"input": [0, null], "output_size": [1, [1, 1, 1], null]}, "threshold": {"input": ["info", null], "threshold": [0, 0.05, 1, 160, 0.6, 0.1, 10, 15, 20, null, -1, 127], "value": [64, 1, 128, 0.0, 20, null, -1, 255], "inplace": [0, true, "value", null]}, "threshold_": {"input": [], "threshold": [], "value": []}, "relu_": {"input": [null]}, "hardtanh": {"input": [0, null], "min_val": [0.0, null], "max_val": [6.0, null], "inplace": [true, null]}, "hardtanh_": {"input": [], "min_val": [], "max_val": []}, "relu6": {"input": [0, null], "inplace": [true, null]}, "elu": {"input": [0, 512, 3, 10, 12, null], "alpha": [0.1, true, 32, 0.05, 0, 0.2, 64, 512, 8, 48, null], "inplace": [false, true, 3, 5, null]}, "clip_grad_norm_": {}, "clip_grad_value_": {}, "parameters_to_vector": {}, "vector_to_parameters": {}, "identity": {}, "random_unstructured": {}, "ConvBn2d": {"in_channels": [null], "out_channels": [], "kernel_size": [], "stride": [], "padding": [], "dilation": [], "groups": [], "padding_mode": [], "eps": [], "momentum": [], "freeze_bn": [], "qconfig": []}, "ConvBnReLU2d": {"in_channels": [], "out_channels": [], "kernel_size": [], "stride": [], "padding": [], "dilation": [], "groups": [], "padding_mode": [], "eps": [], "momentum": [], "freeze_bn": [], "qconfig": []}, "ConvReLU2d": {"in_channels": [], "out_channels": [], "kernel_size": [], "stride": [], "padding": [], "dilation": [], "groups": [], "bias": [], "padding_mode": []}, "ConvReLU3d": {"in_channels": [], "out_channels": [], "kernel_size": [], "stride": [], "padding": [], "dilation": [], "groups": [], "bias": [], "padding_mode": []}, "LinearReLU": {"in_features": [], "out_features": [], "bias": []}, "elu_": {"input": [null], "alpha": [0.1]}, "selu": {"input": [0, null], "inplace": [null]}, "celu": {"input": [0, null], "alpha": [null], "inplace": [null]}, "leaky_relu": {"input": [0, null], "negative_slope": [0.1, 0, 0.2, 0.05, 0.01, null], "inplace": [false, true, null]}, "leaky_relu_": {"input": [null], "negative_slope": [0.1]}, "prelu": {"input": [0, null], "weight": [0, null]}, "rrelu": {"input": [], "lower": [], "upper": [], "training": [], "inplace": []}, "rrelu_": {"input": [], "lower": [], "upper": [], "training": []}, "glu": {"input": [null], "dim": [1, 2, -1, null]}, "l1_unstructured": {}, "random_structured": {}, "ln_structured": {}, "global_unstructured": {}, "Conv2d": {"in_channels": [512, 1, 128, 3, 4, 2, 1024, 256, 5, 2048, 10, 4096, 6, 8, 16, 20, 32, 34, 48, 64, 450, 224, null], "out_channels": [1024, 1, 2, 3, 2048, 128, 6, 4096, 8, 256, 10, 5, 13, 16, 512, 19, 20, 24, 32, 33, 38, 48, 64, 192, 96, 100, null, 120], "kernel_size": [128, 1, 2, 3, 4, 5, 6, 7, 8, 9, [1, 3], 11, [7, 7], [3, 3], [5, 5], [4, 4], [2, 2], [1, 1], [1, 7], [3, 5], [5, 7], [3, 1], [9, 9], [8, 8], null], "stride": [1, 2, 3, 4, [2, 2], [2, 1], null, [1, 1]], "padding": [0, 1, 2, 3, 4, 5, 6, [0, 3], "SAME", [3, 3], [4, 4], [2, 2], [1, 1], [0, 0], [4, 2], [1, 0], [0, 1], 100, [2, 0], null], "dilation": [1, 2, 6, [3, 1], null, [1, 1]], "groups": [1, null], "bias": [false, true, null], "padding_mode": [null]}, "Linear": {"in_features": [9216, 1, 25088, 2, 512, 2048, 1024, 3, 32768, 4096, 10, 0, 12, 4, 5, 8, 16, 19, 20, 16384, 30, 1568, 32, 49, 1536, 50, 3136, 576, 64, 18432, 100352, 1600, 179776, 1100, 84, 90, 2144, 3072, 100, 6250, 110, 120, 124, 128, 1152, 4608, 1176, 160, 1200, 196, 200, 4320, 7680, null, 250, 256, 8192, 768, 1280, 1792, 12544, 6400, 2304, 784, 48400, 41472, 800, 288, 300, 320, 10752, 56180, 3965, 1408, 900, 400, 44944, 3000, 448, 4032, 234432, 1000], "out_features": [128, 1, 1024, 256, 2, 0.5, 4096, 3, 2048, 8, 10, 5, 4, 12544, 6, 520, 400, 512, 16, 20, 25, 30, 32, 800, 40, 300, 9, 1200, 50, 64, 192, 450, 6272, 200, 74, 1100, 80, 81, "lr", 600, 350, 3072, 100, 101, 1000, 108, 625, 500, null, 120], "bias": [false, 0.5, true, null]}, "ReLU": {"inplace": [0.2, true, false, 3, 256, 0.5, 6, 0.4, 1024, 0.123, 10, 13, 16, 0.05, 35, 48, 0.1, 64, 0.02, 0.01, null]}, "ReLU6": {"inplace": [true, null]}, "gelu": {"input": [null]}, "logsigmoid": {"input": [null]}, "hardshrink": {"input": [null], "lambd": []}, "tanhshrink": {"input": []}, "softsign": {"input": [null]}, "softplus": {"input": [null], "beta": [1, null], "threshold": [20]}, "softmin": {"input": [], "dim": [], "_stacklevel": [], "dtype": []}, "softmax": {"input": [0, 1, 2, "value", null, -1], "dim": [0, 1, 2, 3, 4, -2, null, -1], "_stacklevel": [1, 2, 3, "softmax", null], "dtype": [-1, null]}, "custom_from_mask": {}, "remove": {}, "is_pruned": {}, "weight_norm": {}, "remove_weight_norm": {}, "Conv3d": {"in_channels": [0, 1, 2, 3, 32, 8, 16, null], "out_channels": [64, 1, 2, 3, 32, 8, 10, 16, null], "kernel_size": [[3, 3, 3], 1, [5, 5, 3], 3, 4, 5, [5, 7, 11], [7, 7, 7], null, [1, 1, 1], [1, 3, 3]], "stride": [[2, 2, 2], 2, 1, 3, null, [1, 1, 1]], "padding": [0, 1, [0, 1, 1], 2, [2, 2, 1], [0, 0, 0], null, [1, 1, 1]], "dilation": [2, null], "groups": [null], "bias": [false, null], "padding_mode": []}, "FloatFunctional": {}, "softshrink": {"input": [], "lambd": []}, "gumbel_softmax": {"logits": [null], "tau": [1, null], "hard": [true], "eps": [], "dim": []}, "log_softmax": {"input": [0, 1, 2, "value", null], "dim": [0, 1, 2, 4, null, -1], "_stacklevel": [0, 5, null], "dtype": [null]}, "tanh": {"input": [0, 1, "value", null, -3.5]}, "sigmoid": {"input": [0, 2.2, "value", null]}, "batch_norm": {"input": [0, 128, "final_bn", null], "running_mean": [0, 0.9, "bn", null], "running_var": [0, null], "weight": [0, null], "bias": [0, null], "training": [false, true, null], "momentum": [0.0, 1, 0.1, 0.99, null], "eps": [1e-05, 1, null]}, "instance_norm": {"input": [null], "running_mean": [0, null], "running_var": [0, null], "weight": [0], "bias": [0, null], "use_input_stats": [true, null], "momentum": [0.0, 0.1], "eps": [1e-05, null]}, "spectral_norm": {}, "remove_spectral_norm": {}, "PackedSequence": {}, "pack_padded_sequence": {}, "pad_packed_sequence": {}, "pad_sequence": {}, "QFunctional": {}, "Quantize": {"scale": [null], "zero_point": [null], "dtype": []}, "DeQuantize": {}, "LSTM": {}, "layer_norm": {"input": [0, null], "normalized_shape": [null], "weight": [null], "bias": [null], "eps": [1e-06, null]}, "local_response_norm": {"input": [0, null], "size": [0, 5], "alpha": [0], "beta": [0], "k": [0, 2.0]}, "normalize": {"input": ["", "NFKC", 0, "NFKD", "# Adapted from https://github.com/NVIDIA/NeMo/blob/r0.9/collections/nemo_asr/\n# Copyright (C) 2020 Xilinx (Giuseppe Franco)\n# Copyright (C) 2019 NVIDIA CORPORATION.\n#\n# All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport random\n\nimport torch\nimport torch.nn as nn\n\n\nclass SpecAugment(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random continuous horisontal or\n    vertical segments of the spectrogram as described in\n    SpecAugment (https://arxiv.org/abs/1904.08779).\n\n    params:\n    freq_masks - how many frequency segments should be cut\n    time_masks - how many time segments should be cut\n    freq_width - maximum number of frequencies to be cut in one segment\n    time_width - maximum number of time steps to be cut in one segment\n    \"\"\"\n    def __init__(\n        self,\n        freq_masks=0,\n        time_masks=0,\n        freq_width=10,\n        time_width=10,\n        rng=None\n    ):\n        super(SpecAugment, self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.freq_masks = freq_masks\n        self.time_masks = time_masks\n\n        self.freq_width = freq_width\n        self.time_width = time_width\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.freq_masks):\n                x_left = int(self._rng.uniform(\n                    0, sh[1] - self.freq_width))\n\n                w = int(self._rng.uniform(0, self.freq_width))\n\n                mask[idx, x_left:x_left + w, :] = 1\n\n            for i in range(self.time_masks):\n                y_left = int(self._rng.uniform(\n                    0, sh[2] - self.time_width))\n\n                w = int(self._rng.uniform(0, self.time_width))\n\n                mask[idx, :,\n                     y_left:y_left + w] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x\n\n\nclass SpecCutout(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random rectangles in the spectrogram\n    as described in (https://arxiv.org/abs/1708.04552).\n\n    params:\n    rect_masks - how many rectangular masks should be cut\n    rect_freq - maximum size of cut rectangles along the frequency dimension\n    rect_time - maximum size of cut rectangles along the time dimension\n    \"\"\"\n    def __init__(\n        self,\n        rect_masks=0,\n        rect_time=5,\n        rect_freq=20,\n        rng=None\n    ):\n        super(SpecCutout, self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.rect_masks = rect_masks\n        self.rect_time = rect_time\n        self.rect_freq = rect_freq\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.rect_masks):\n                rect_x = int(self._rng.uniform(\n                    0, sh[1] - self.rect_freq))\n                rect_y = int(self._rng.uniform(\n                    0, sh[2] - self.rect_time))\n\n                w_x = int(self._rng.uniform(0, self.rect_time))\n                w_y = int(self._rng.uniform(0, self.rect_freq))\n\n                mask[idx, rect_x:rect_x + w_x,\n                     rect_y:rect_y + w_y] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x\n", "NFD", "value", null, ["dim", "0"], "NFC", ["dim", "1"]], "p": [0, 1, 2, 3, [0], "l1", "# Adapted from https://github.com/NVIDIA/NeMo/blob/r0.9/collections/nemo_asr/\n# Copyright (C) 2020 Xilinx (Giuseppe Franco)\n# Copyright (C) 2019 NVIDIA CORPORATION.\n#\n# All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport random\n\nimport torch\nimport torch.nn as nn\n\n\nclass SpecAugment(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random continuous horisontal or\n    vertical segments of the spectrogram as described in\n    SpecAugment (https://arxiv.org/abs/1904.08779).\n\n    params:\n    freq_masks - how many frequency segments should be cut\n    time_masks - how many time segments should be cut\n    freq_width - maximum number of frequencies to be cut in one segment\n    time_width - maximum number of time steps to be cut in one segment\n    \"\"\"\n    def __init__(\n        self,\n        freq_masks=0,\n        time_masks=0,\n        freq_width=10,\n        time_width=10,\n        rng=None\n    ):\n        super(SpecAugment, self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.freq_masks = freq_masks\n        self.time_masks = time_masks\n\n        self.freq_width = freq_width\n        self.time_width = time_width\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.freq_masks):\n                x_left = int(self._rng.uniform(\n                    0, sh[1] - self.freq_width))\n\n                w = int(self._rng.uniform(0, self.freq_width))\n\n                mask[idx, x_left:x_left + w, :] = 1\n\n            for i in range(self.time_masks):\n                y_left = int(self._rng.uniform(\n                    0, sh[2] - self.time_width))\n\n                w = int(self._rng.uniform(0, self.time_width))\n\n                mask[idx, :,\n                     y_left:y_left + w] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x\n\n\nclass SpecCutout(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random rectangles in the spectrogram\n    as described in (https://arxiv.org/abs/1708.04552).\n\n    params:\n    rect_masks - how many rectangular masks should be cut\n    rect_freq - maximum size of cut rectangles along the frequency dimension\n    rect_time - maximum size of cut rectangles along the time dimension\n    \"\"\"\n    def __init__(\n        self,\n        rect_masks=0,\n        rect_time=5,\n        rect_freq=20,\n        rng=None\n    ):\n        super(SpecCutout, self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.rect_masks = rect_masks\n        self.rect_time = rect_time\n        self.rect_freq = rect_freq\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.rect_masks):\n                rect_x = int(self._rng.uniform(\n                    0, sh[1] - self.rect_freq))\n                rect_y = int(self._rng.uniform(\n                    0, sh[2] - self.rect_time))\n\n                w_x = int(self._rng.uniform(0, self.rect_time))\n                w_y = int(self._rng.uniform(0, self.rect_freq))\n\n                mask[idx, rect_x:rect_x + w_x,\n                     rect_y:rect_y + w_y] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x\n", "l2", "value", null, -1], "dim": [0, 1, 2, 128.0, 0.456, null, -1, 255], "eps": [false, 1e-05, 1e-10, 1e-12, null, 0.0001, 1e-06, 255], "out": [null]}, "bilinear": {"input1": [null], "input2": [0, null], "weight": [null], "bias": [null]}, "pack_sequence": {}, "add_module": {"name": ["adapter_norm", "bn2", "list_embedding_0", "conv_out", "emb_luts", "block1", "skip", "down1", "residual_block1", "lm_embedding_0", "Conv2d", "contractive_0", "flatten", "pool1", "selayer", "maxpool", "xconvs", "conv_1", "conv0", "SELayer", "denselayer_1", "cov", "firstconv", "relu", "bbox_branch", "scale_block1", "linear", "model_0", "attention_0", "branch2", "c0", "L0", "discriminator_0", "cls_tower", "layer_0", "denselayer1", "conv.1", "in_0", "autoencoder", "embed", "Bottleneck_1x1", "last", "dense_layer_-1", "head_layer_-1", null, "reduce1", "linear1", "resolve0", "ini", "char_conv_0", "conv1_1", "cnn_0", "stem1_unit", "generator", "init_block", "conv", "enc1_1", "norm.1", "resnet_block1", "DAB_Module_1_0", "bmm", "shortcut_conv", "norm", "dropout", "final_pool", "bn", "recurrent_0", "linear_1", "layer1", "norm_1", "fc1", "f_conv1", "norm1", "conv_0", "Dropout", "block_0", "branch1", "downsample", "conv1", "unit1", "denseblock1", "amp1", "vgg", "global average", "class_wise", "Pooling", "conv_layer_0", "0", "conv2"], "module": [null]}, "apply": {}, "dropout": {"input": [0, 100, null], "p": [0.05, 0.5, 0.2, 0.3, 0, 0.6, 0.25, 0.7, 0.9, 0.9999999999, 0.92, 0.8, null, 0.1, 0.001], "training": [false, true, null], "inplace": [false, true, null]}, "alpha_dropout": {"input": [], "p": [], "training": [], "inplace": []}, "dropout2d": {"input": [null], "p": [0.1, 0.5, null], "training": [null], "inplace": [true]}, "dropout3d": {"input": [], "p": [], "training": [], "inplace": []}, "embedding": {"input": [0, "{}", "data/glove6b_init_300d.npy", 1, null, "../github_crawler/torch_pyfiles"], "weight": [1, " ", null], "padding_idx": [0, -1, null], "max_norm": [0, null], "norm_type": [2, null], "scale_grad_by_freq": [false, null], "sparse": [false, null]}, "buffers": {"recurse": [false, true, null]}, "children": {}, "cpu": {}, "cuda": {"device": [0, 1, null]}, "double": {}, "eval": {}, "extra_repr": {}, "float": {}, "forward": {"tgt": [0, true, null], "memory": [0, 1, 6, ["use_gpu", "False"], ["string_len", "None"], ["reduce", "True"], ["hidden_init", "None"], null, ["string2_len", "None"], ["query_len", "None"]], "tgt_mask": [0, 256, 2, 32, [], "value", null], "memory_mask": [0, "value", null], "tgt_key_padding_mask": [null], "memory_key_padding_mask": [null]}, "embedding_bag": {"input": [], "weight": [], "offsets": [], "max_norm": [], "norm_type": [], "scale_grad_by_freq": [], "mode": [], "sparse": [], "per_sample_weights": []}, "one_hot": {"tensor": [0, null], "num_classes": [1, 2, 3, 10, null, -1]}, "half": {}, "load_state_dict": {"state_dict": [0, "123", null], "strict": [false, true, null]}, "modules": {}, "named_buffers": {"prefix": [], "recurse": [true]}, "named_children": {}, "named_modules": {"memo": [null], "prefix": ["__module", null]}, "named_parameters": {"prefix": ["", null], "recurse": [false, true, null]}, "parameters": {"recurse": [false, true, [0], null]}, "pairwise_distance": {"x1": [null], "x2": [null], "p": [2, null], "eps": [null], "keepdim": []}, "cosine_similarity": {"x1": [null], "x2": [null], "dim": [0, 1, 2, 3, null, -1], "eps": [1e-08, null]}, "pdist": {"input": [null], "p": ["cosine", null]}, "binary_cross_entropy": {"input": [0, null], "target": [null], "weight": [0, null], "size_average": [false, null], "reduce": [null], "reduction": ["mean", "none", "sum"]}, "binary_cross_entropy_with_logits": {"input": [0, null], "target": [null], "weight": [0, null], "size_average": [false, true, null], "reduce": [false, null], "reduction": ["mean", "none", "sum", null, "elementwise_mean"], "pos_weight": [null]}, "register_backward_hook": {"hook": [null]}, "register_buffer": {"name": ["diag_head_idx", "signal", "faces", "pe", "p", "active_dims", "mean", "hidden", "prior_boxes", "buff", "J_regressor_extra", "edges", "init_pose", "_tmp_running_mean", "k", "one_hot", "grid", "updated_strategy", "version", "_num_evals", "w_nom", "p_z_loc", "_indices_shape_params", "atomic_mass", "low_tensor", "boxes", "pos", "depth_weight", "prior_cluster_logits", "filt", "gp_obs_matrix", "base10", "lambda_", "inv_freq", "A", "inverse_kernel", "position_encoding", "scale", "size_templates", "weight", "shift", "b", "_count", "wc_blank", "anchors", "proj", "eta", "_filters", "r", "sum", "obs_loc", "_shape_mean", "coords", "final_logits_bias", "full_grid", "loc", "has_initialized_grid", "total", "logprob_noise", "powers", "R", "forward_basis", "angle_prior_idxs", "a", "_step", "params", "permutation", "reset", "running_means", "constraint_mask", "bias", "mask_d", null, "pixel_mean", "inducing_points", "total_timestep", "tiny", "real_label", "analysis_filter", "u0", "x", "running_bce_loss", "_float_tensor", "phi", "vertices", "lut", "mean_theta", "pos_table", "choices_tensor", "obs_matrix", "value", "running_stats", "max_action", "index", "pos_embs", "_grid", "dt", "_binary_filter_pruning_mask", "fixed_embedding", "beta", "saved_tiny", "mem_bias", "mesh", "ema_cluster_size", "buf", "triangular_mask", "assignments", "kernel_size", "th_betas", "V_avg", "u", "freq", "_true_positive_sum", "step", "prob", "running_mean", "eps", "min_val", "window_", "mask", "s", "i", "zero_point", "nu", "v_template", "sn_u", "h", "init_seq", "smooth_kernel", "mel_basis", "inv_indices", "_binary_mask", "kernel", "moving_mean", "h_t", "gaussian_filter", "enabled", "scale_x", "leaky_rate", "firing_rates", "weight_weather", "total_ops", "melmat", "self_mask_value_float16", "dummy_buf", "weight_epsilon", "window", "uniform", "grad_outputs", "xTx", "support_atoms", "running_mean_0"], "tensor": [0, "value", null], "persistent": [0, null]}, "register_forward_hook": {"hook": [null]}, "register_forward_pre_hook": {"hook": [null]}, "register_parameter": {"name": [0, "inducing_points", "raw_alpha", "constant", "normalize_scalar", "covar_factor", "raw_noise", "offset", "raw_lengthscale", "raw_period_length", "input_vars", "root", "variational_mean", "sem_encoder", "weights", "W_1", "raw_offset", "task_noise_corr", "wzp", "depth_attentions", "sqrt_end_time", "mixing_weights", "variational_cluster_logits", "old_weight", "visual_scale_text", "W_hat", null, "bias_mu", "bias_ih", "raw_angle", "mixing_params", "transition_matrix", "width_attentions", "weight", "norm_alpha", "bias", "prior_h", "raw_angular_weights", "mesh", "raw_mixture_weights", "raw_outputscale", "b"], "param": [0, "u1", "inverse_bandwidths", "mean_value", "alpha", "noise_variance", null, "_b", "warping"]}, "requires_grad_": {"requires_grad": [false, true, "value", null]}, "state_dict": {}, "to": {}, "poisson_nll_loss": {"input": [null], "target": [null], "log_input": [], "full": [], "size_average": [], "eps": [], "reduce": [], "reduction": []}, "cosine_embedding_loss": {"input1": [null], "input2": [null], "target": [null], "margin": [], "size_average": [], "reduce": [], "reduction": ["mean"]}, "cross_entropy": {"input": [0, null], "target": [0, null], "weight": [0, 0.4, null], "size_average": [false, true, null], "ignore_index": [7, null, 250, -100, -1, 255], "reduce": [0, true, null], "reduction": ["mean", "none", "sum", null, "elementwise_mean"]}, "train": {"mode": [false, true, "resources/taggers/example-ner", "regression_train/", "train", "# Adapted from https://github.com/NVIDIA/NeMo/blob/r0.9/collections/nemo_asr/\n# Copyright (C) 2020 Xilinx (Giuseppe Franco)\n# Copyright (C) 2019 NVIDIA CORPORATION.\n#\n# All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport random\n\nimport torch\nimport torch.nn as nn\n\n\nclass SpecAugment(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random continuous horisontal or\n    vertical segments of the spectrogram as described in\n    SpecAugment (https://arxiv.org/abs/1904.08779).\n\n    params:\n    freq_masks - how many frequency segments should be cut\n    time_masks - how many time segments should be cut\n    freq_width - maximum number of frequencies to be cut in one segment\n    time_width - maximum number of time steps to be cut in one segment\n    \"\"\"\n    def __init__(\n        self,\n        freq_masks=0,\n        time_masks=0,\n        freq_width=10,\n        time_width=10,\n        rng=None\n    ):\n        super(SpecAugment, self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.freq_masks = freq_masks\n        self.time_masks = time_masks\n\n        self.freq_width = freq_width\n        self.time_width = time_width\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.freq_masks):\n                x_left = int(self._rng.uniform(\n                    0, sh[1] - self.freq_width))\n\n                w = int(self._rng.uniform(0, self.freq_width))\n\n                mask[idx, x_left:x_left + w, :] = 1\n\n            for i in range(self.time_masks):\n                y_left = int(self._rng.uniform(\n                    0, sh[2] - self.time_width))\n\n                w = int(self._rng.uniform(0, self.time_width))\n\n                mask[idx, :,\n                     y_left:y_left + w] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x\n\n\nclass SpecCutout(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random rectangles in the spectrogram\n    as described in (https://arxiv.org/abs/1708.04552).\n\n    params:\n    rect_masks - how many rectangular masks should be cut\n    rect_freq - maximum size of cut rectangles along the frequency dimension\n    rect_time - maximum size of cut rectangles along the time dimension\n    \"\"\"\n    def __init__(\n        self,\n        rect_masks=0,\n        rect_time=5,\n        rect_freq=20,\n        rng=None\n    ):\n        super(SpecCutout, self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.rect_masks = rect_masks\n        self.rect_time = rect_time\n        self.rect_freq = rect_freq\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.rect_masks):\n                rect_x = int(self._rng.uniform(\n                    0, sh[1] - self.rect_freq))\n                rect_y = int(self._rng.uniform(\n                    0, sh[2] - self.rect_time))\n\n                w_x = int(self._rng.uniform(0, self.rect_time))\n                w_y = int(self._rng.uniform(0, self.rect_freq))\n\n                mask[idx, rect_x:rect_x + w_x,\n                     rect_y:rect_y + w_y] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x\n", [], 20, null]}, "type": {"dst_type": [0, 1, "", "uint16", "torch.FloatTensor", "freefont/FreeSerifBold.ttf", "/usr/share/fonts/truetype/freefont/FreeMonoBold.ttf", "i8", "torch.LongTensor", "../github_crawler/torch_pyfiles/Xilinx__brevitas.csv/node_type.txt", "TaskSpec", "byte", "O", "arialbd", "Enum", "i4", "./calibril.ttf", "float32", "SkipLayerNormalization", "int32", "int8", "category", "../github_crawler/torch_pyfiles/Xilinx__brevitas.csv", "float", "i", ["nl", "''"], "datetime64[ns]", "float64", "int16", "arial.ttf", "interval", "f4", "torch.DoubleTensor", "f", "LayerType", "../github_crawler/torch_pyfiles", "# Adapted from https://github.com/NVIDIA/NeMo/blob/r0.9/collections/nemo_asr/\n# Copyright (C) 2020 Xilinx (Giuseppe Franco)\n# Copyright (C) 2019 NVIDIA CORPORATION.\n#\n# All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport random\n\nimport torch\nimport torch.nn as nn\n\n\nclass SpecAugment(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random continuous horisontal or\n    vertical segments of the spectrogram as described in\n    SpecAugment (https://arxiv.org/abs/1904.08779).\n\n    params:\n    freq_masks - how many frequency segments should be cut\n    time_masks - how many time segments should be cut\n    freq_width - maximum number of frequencies to be cut in one segment\n    time_width - maximum number of time steps to be cut in one segment\n    \"\"\"\n    def __init__(\n        self,\n        freq_masks=0,\n        time_masks=0,\n        freq_width=10,\n        time_width=10,\n        rng=None\n    ):\n        super(SpecAugment, self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.freq_masks = freq_masks\n        self.time_masks = time_masks\n\n        self.freq_width = freq_width\n        self.time_width = time_width\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.freq_masks):\n                x_left = int(self._rng.uniform(\n                    0, sh[1] - self.freq_width))\n\n                w = int(self._rng.uniform(0, self.freq_width))\n\n                mask[idx, x_left:x_left + w, :] = 1\n\n            for i in range(self.time_masks):\n                y_left = int(self._rng.uniform(\n                    0, sh[2] - self.time_width))\n\n                w = int(self._rng.uniform(0, self.time_width))\n\n                mask[idx, :,\n                     y_left:y_left + w] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x\n\n\nclass SpecCutout(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random rectangles in the spectrogram\n    as described in (https://arxiv.org/abs/1708.04552).\n\n    params:\n    rect_masks - how many rectangular masks should be cut\n    rect_freq - maximum size of cut rectangles along the frequency dimension\n    rect_time - maximum size of cut rectangles along the time dimension\n    \"\"\"\n    def __init__(\n        self,\n        rect_masks=0,\n        rect_time=5,\n        rect_freq=20,\n        rng=None\n    ):\n        super(SpecCutout, self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.rect_masks = rect_masks\n        self.rect_time = rect_time\n        self.rect_freq = rect_freq\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.rect_masks):\n                rect_x = int(self._rng.uniform(\n                    0, sh[1] - self.rect_freq))\n                rect_y = int(self._rng.uniform(\n                    0, sh[2] - self.rect_time))\n\n                w_x = int(self._rng.uniform(0, self.rect_time))\n                w_y = int(self._rng.uniform(0, self.rect_freq))\n\n                mask[idx, rect_x:rect_x + w_x,\n                     rect_y:rect_y + w_y] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x\n", "int", "object", ">i2", "f8", "value", "torch.cuda.FloatTensor", "v", "uint8", "Comic Sans MS.ttf", "dummy", "uint32", "https://hyperdash.io", "bool", "assets/arial.ttf", "d", ["bias", "False"], "/home/blue/Documents/api-representation-learning/commons/SourceSansPro-Regular.ttf", "ustr", "non_serial", "Args", "DejaVuSansMono.ttf", null, "str", "attrib_dict", "int64", 255.0]}, "zero_grad": {}, "append": {"parameter": [0, "../dataset", 1, "", NaN, "str_1", 2, 1024, [["tf.Summary.Value(tag", "'%s/%d' % (tag, i), image", "img_sum)"]], "# Adapted from https://github.com/NVIDIA/NeMo/blob/r0.9/collections/nemo_asr/ # Copyright (C) 2020 Xilinx (Giuseppe Franco) # Copyright (C) 2019 NVIDIA CORPORATION. # # All Rights Reserved. # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. import random import torch import torch.nn as nn class SpecAugment(nn.Module): \"\"\" Zeroes out(cuts) random continuous horisontal or vertical segments of the spectrogram as described in SpecAugment (https://arxiv.org/abs/1904.08779). params: freq_masks - how many frequency segments should be cut time_masks - how many time segments should be cut freq_width - maximum number of frequencies to be cut in one segment time_width - maximum number of time steps to be cut in one segment \"\"\" def __init__( self, freq_masks=0, time_masks=0, freq_width=10, time_width=10, rng=None ): super(SpecAugment, self).__init__() self._rng = random.Random() if rng is None else rng self.freq_masks = freq_masks self.time_masks = time_masks self.freq_width = freq_width self.time_width = time_width @torch.no_grad() def forward(self, x): sh = x.shape mask = torch.zeros(x.shape).byte() for idx in range(sh[0]): for i in range(self.freq_masks): x_left = int(self._rng.uniform( 0, sh[1] - self.freq_width)) w = int(self._rng.uniform(0, self.freq_width)) mask[idx, x_left:x_left + w, :] = 1 for i in range(self.time_masks): y_left = int(self._rng.uniform( 0, sh[2] - self.time_width)) w = int(self._rng.uniform(0, self.time_width)) mask[idx, :, y_left:y_left + w] = 1 x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0) return x class SpecCutout(nn.Module): \"\"\" Zeroes out(cuts) random rectangles in the spectrogram as described in (https://arxiv.org/abs/1708.04552). params: rect_masks - how many rectangular masks should be cut rect_freq - maximum size of cut rectangles along the frequency dimension rect_time - maximum size of cut rectangles along the time dimension \"\"\" def __init__( self, rect_masks=0, rect_time=5, rect_freq=20, rng=None ): super(SpecCutout, self).__init__() self._rng = random.Random() if rng is None else rng self.rect_masks = rect_masks self.rect_time = rect_time self.rect_freq = rect_freq @torch.no_grad() def forward(self, x): sh = x.shape mask = torch.zeros(x.shape).byte() for idx in range(sh[0]): for i in range(self.rect_masks): rect_x = int(self._rng.uniform( 0, sh[1] - self.rect_freq)) rect_y = int(self._rng.uniform( 0, sh[2] - self.rect_time)) w_x = int(self._rng.uniform(0, self.rect_time)) w_y = int(self._rng.uniform(0, self.rect_freq)) mask[idx, rect_x:rect_x + w_x, rect_y:rect_y + w_y] = 1 x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0) return x", 7, 4, 3, "./finetune/", "__iter__", "../../python", "Copyright", "-lc", "./PoseEstimation", "value2", "root", "differentiable", "idt_B", "self", "source mars_env/bin/activate", "cupy", "doc", "--user", "../darts", "var1", "abc", "/root/3DOD_thesis/utils", "./apex", "/home/blue/Documents/api-representation-learning/src", "sphinx.ext.intersphinx", "BCEWithLogitsLoss", "spherical", "/home/fregu856/3DOD_thesis/utils", "-", [0, "tuple([i, value])"], "pycocoevalcap", "models", "unknown", "epoch", "pos", "C", "# Adapted from https://github.com/NVIDIA/NeMo/blob/r0.9/collections/nemo_asr/\n# Copyright (C) 2020 Xilinx (Giuseppe Franco)\n# Copyright (C) 2019 NVIDIA CORPORATION.\n#\n# All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport random\n\nimport torch\nimport torch.nn as nn\n\n\nclass SpecAugment(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random continuous horisontal or\n    vertical segments of the spectrogram as described in\n    SpecAugment (https://arxiv.org/abs/1904.08779).\n\n    params:\n    freq_masks - how many frequency segments should be cut\n    time_masks - how many time segments should be cut\n    freq_width - maximum number of frequencies to be cut in one segment\n    time_width - maximum number of time steps to be cut in one segment\n    \"\"\"\n    def __init__(\n        self,\n        freq_masks=0,\n        time_masks=0,\n        freq_width=10,\n        time_width=10,\n        rng=None\n    ):\n        super(SpecAugment, self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.freq_masks = freq_masks\n        self.time_masks = time_masks\n\n        self.freq_width = freq_width\n        self.time_width = time_width\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.freq_masks):\n                x_left = int(self._rng.uniform(\n                    0, sh[1] - self.freq_width))\n\n                w = int(self._rng.uniform(0, self.freq_width))\n\n                mask[idx, x_left:x_left + w, :] = 1\n\n            for i in range(self.time_masks):\n                y_left = int(self._rng.uniform(\n                    0, sh[2] - self.time_width))\n\n                w = int(self._rng.uniform(0, self.time_width))\n\n                mask[idx, :,\n                     y_left:y_left + w] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x\n\n\nclass SpecCutout(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random rectangles in the spectrogram\n    as described in (https://arxiv.org/abs/1708.04552).\n\n    params:\n    rect_masks - how many rectangular masks should be cut\n    rect_freq - maximum size of cut rectangles along the frequency dimension\n    rect_time - maximum size of cut rectangles along the time dimension\n    \"\"\"\n    def __init__(\n        self,\n        rect_masks=0,\n        rect_time=5,\n        rect_freq=20,\n        rng=None\n    ):\n        super(SpecCutout, self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.rect_masks = rect_masks\n        self.rect_time = rect_time\n        self.rect_freq = rect_freq\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.rect_masks):\n                rect_x = int(self._rng.uniform(\n                    0, sh[1] - self.rect_freq))\n                rect_y = int(self._rng.uniform(\n                    0, sh[2] - self.rect_time))\n\n                w_x = int(self._rng.uniform(0, self.rect_time))\n                w_y = int(self._rng.uniform(0, self.rect_freq))\n\n                mask[idx, rect_x:rect_x + w_x,\n                     rect_y:rect_y + w_y] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x\n", ".polyaxon.com", ["#", "Adapted", "from", "https://github.com/NVIDIA/NeMo/blob/r0.9/collections/nemo_asr/\n#", "Copyright", "(C)", "2020", "Xilinx", "(Giuseppe", "Franco)\n#", "Copyright", "(C)", "2019", "NVIDIA", "CORPORATION.\n#\n#", "All", "Rights", "Reserved.\n#\n#", "Licensed", "under", "the", "Apache", "License,", "Version", "2.0", "(the", "\"License\");\n#", "you", "may", "not", "use", "this", "file", "except", "in", "compliance", "with", "the", "License.\n#", "You", "may", "obtain", "a", "copy", "of", "the", "License", "at\n#\n#", "", "", "", "", "", "http://www.apache.org/licenses/LICENSE-2.0\n#\n#", "Unless", "required", "by", "applicable", "law", "or", "agreed", "to", "in", "writing,", "software\n#", "distributed", "under", "the", "License", "is", "distributed", "on", "an", "\"AS", "IS\"", "BASIS,\n#", "WITHOUT", "WARRANTIES", "OR", "CONDITIONS", "OF", "ANY", "KIND,", "either", "express", "or", "implied.\n#", "See", "the", "License", "for", "the", "specific", "language", "governing", "permissions", "and\n#", "limitations", "under", "the", "License.\n\nimport", "random\n\nimport", "torch\nimport", "torch.nn", "as", "nn\n\n\nclass", "SpecAugment(nn.Module):\n", "", "", "", "\"\"\"\n", "", "", "", "Zeroes", "out(cuts)", "random", "continuous", "horisontal", "or\n", "", "", "", "vertical", "segments", "of", "the", "spectrogram", "as", "described", "in\n", "", "", "", "SpecAugment", "(https://arxiv.org/abs/1904.08779).\n\n", "", "", "", "params:\n", "", "", "", "freq_masks", "-", "how", "many", "frequency", "segments", "should", "be", "cut\n", "", "", "", "time_masks", "-", "how", "many", "time", "segments", "should", "be", "cut\n", "", "", "", "freq_width", "-", "maximum", "number", "of", "frequencies", "to", "be", "cut", "in", "one", "segment\n", "", "", "", "time_width", "-", "maximum", "number", "of", "time", "steps", "to", "be", "cut", "in", "one", "segment\n", "", "", "", "\"\"\"\n", "", "", "", "def", "__init__(\n", "", "", "", "", "", "", "", "self,\n", "", "", "", "", "", "", "", "freq_masks=0,\n", "", "", "", "", "", "", "", "time_masks=0,\n", "", "", "", "", "", "", "", "freq_width=10,\n", "", "", "", "", "", "", "", "time_width=10,\n", "", "", "", "", "", "", "", "rng=None\n", "", "", "", "):\n", "", "", "", "", "", "", "", "super(SpecAugment,", "self).__init__()\n\n", "", "", "", "", "", "", "", "self._rng", "=", "random.Random()", "if", "rng", "is", "None", "else", "rng\n\n", "", "", "", "", "", "", "", "self.freq_masks", "=", "freq_masks\n", "", "", "", "", "", "", "", "self.time_masks", "=", "time_masks\n\n", "", "", "", "", "", "", "", "self.freq_width", "=", "freq_width\n", "", "", "", "", "", "", "", "self.time_width", "=", "time_width\n\n", "", "", "", "@torch.no_grad()\n", "", "", "", "def", "forward(self,", "x):\n", "", "", "", "", "", "", "", "sh", "=", "x.shape\n\n", "", "", "", "", "", "", "", "mask", "=", "torch.zeros(x.shape).byte()\n\n", "", "", "", "", "", "", "", "for", "idx", "in", "range(sh[0]):\n", "", "", "", "", "", "", "", "", "", "", "", "for", "i", "in", "range(self.freq_masks):\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "x_left", "=", "int(self._rng.uniform(\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "0,", "sh[1]", "-", "self.freq_width))\n\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "w", "=", "int(self._rng.uniform(0,", "self.freq_width))\n\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "mask[idx,", "x_left:x_left", "+", "w,", ":]", "=", "1\n\n", "", "", "", "", "", "", "", "", "", "", "", "for", "i", "in", "range(self.time_masks):\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "y_left", "=", "int(self._rng.uniform(\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "0,", "sh[2]", "-", "self.time_width))\n\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "w", "=", "int(self._rng.uniform(0,", "self.time_width))\n\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "mask[idx,", ":,\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "y_left:y_left", "+", "w]", "=", "1\n\n", "", "", "", "", "", "", "", "x", "=", "x.masked_fill(mask.type(torch.bool).to(device=x.device),", "0)\n\n", "", "", "", "", "", "", "", "return", "x\n\n\nclass", "SpecCutout(nn.Module):\n", "", "", "", "\"\"\"\n", "", "", "", "Zeroes", "out(cuts)", "random", "rectangles", "in", "the", "spectrogram\n", "", "", "", "as", "described", "in", "(https://arxiv.org/abs/1708.04552).\n\n", "", "", "", "params:\n", "", "", "", "rect_masks", "-", "how", "many", "rectangular", "masks", "should", "be", "cut\n", "", "", "", "rect_freq", "-", "maximum", "size", "of", "cut", "rectangles", "along", "the", "frequency", "dimension\n", "", "", "", "rect_time", "-", "maximum", "size", "of", "cut", "rectangles", "along", "the", "time", "dimension\n", "", "", "", "\"\"\"\n", "", "", "", "def", "__init__(\n", "", "", "", "", "", "", "", "self,\n", "", "", "", "", "", "", "", "rect_masks=0,\n", "", "", "", "", "", "", "", "rect_time=5,\n", "", "", "", "", "", "", "", "rect_freq=20,\n", "", "", "", "", "", "", "", "rng=None\n", "", "", "", "):\n", "", "", "", "", "", "", "", "super(SpecCutout,", "self).__init__()\n\n", "", "", "", "", "", "", "", "self._rng", "=", "random.Random()", "if", "rng", "is", "None", "else", "rng\n\n", "", "", "", "", "", "", "", "self.rect_masks", "=", "rect_masks\n", "", "", "", "", "", "", "", "self.rect_time", "=", "rect_time\n", "", "", "", "", "", "", "", "self.rect_freq", "=", "rect_freq\n\n", "", "", "", "@torch.no_grad()\n", "", "", "", "def", "forward(self,", "x):\n", "", "", "", "", "", "", "", "sh", "=", "x.shape\n\n", "", "", "", "", "", "", "", "mask", "=", "torch.zeros(x.shape).byte()\n\n", "", "", "", "", "", "", "", "for", "idx", "in", "range(sh[0]):\n", "", "", "", "", "", "", "", "", "", "", "", "for", "i", "in", "range(self.rect_masks):\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "rect_x", "=", "int(self._rng.uniform(\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "0,", "sh[1]", "-", "self.rect_freq))\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "rect_y", "=", "int(self._rng.uniform(\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "0,", "sh[2]", "-", "self.rect_time))\n\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "w_x", "=", "int(self._rng.uniform(0,", "self.rect_time))\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "w_y", "=", "int(self._rng.uniform(0,", "self.rect_freq))\n\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "mask[idx,", "rect_x:rect_x", "+", "w_x,\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "rect_y:rect_y", "+", "w_y]", "=", "1\n\n", "", "", "", "", "", "", "", "x", "=", "x.masked_fill(mask.type(torch.bool).to(device=x.device),", "0)\n\n", "", "", "", "", "", "", "", "return", "x"], "/home/blue/Documents/api-representation-learning/commons/dla", "coco-caption", "rowcount", "../weight/yolov4_1_3_608_608.onnx", "stuff to append", "asm", "Att0", "input", " # Adapted from https://github.com/NVIDIA/NeMo/blob/r0.9/collections/nemo_asr/\n# Copyright (C) 2020 Xilinx (Giuseppe Franco)\n# Copyright (C) 2019 NVIDIA CORPORATION.\n#\n# All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport random\n\nimport torch\nimport torch.nn as nn\n\n\nclass SpecAugment(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random continuous horisontal or\n    vertical segments of the spectrogram as described in\n    SpecAugment (https://arxiv.org/abs/1904.08779).\n\n    params:\n    freq_masks - how many frequency segments should be cut\n    time_masks - how many time segments should be cut\n    freq_width - maximum number of frequencies to be cut in one segment\n    time_width - maximum number of time steps to be cut in one segment\n    \"\"\"\n    def __init__(\n        self,\n        freq_masks=0,\n        time_masks=0,\n        freq_width=10,\n        time_width=10,\n        rng=None\n    ):\n        super(SpecAugment, self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.freq_masks = freq_masks\n        self.time_masks = time_masks\n\n        self.freq_width = freq_width\n        self.time_width = time_width\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.freq_masks):\n                x_left = int(self._rng.uniform(\n                    0, sh[1] - self.freq_width))\n\n                w = int(self._rng.uniform(0, self.freq_width))\n\n                mask[idx, x_left:x_left + w, :] = 1\n\n            for i in range(self.time_masks):\n                y_left = int(self._rng.uniform(\n                    0, sh[2] - self.time_width))\n\n                w = int(self._rng.uniform(0, self.time_width))\n\n                mask[idx, :,\n                     y_left:y_left + w] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x\n\n\nclass SpecCutout(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random rectangles in the spectrogram\n    as described in (https://arxiv.org/abs/1708.04552).\n\n    params:\n    rect_masks - how many rectangular masks should be cut\n    rect_freq - maximum size of cut rectangles along the frequency dimension\n    rect_time - maximum size of cut rectangles along the time dimension\n    \"\"\"\n    def __init__(\n        self,\n        rect_masks=0,\n        rect_time=5,\n        rect_freq=20,\n        rng=None\n    ):\n        super(SpecCutout, self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.rect_masks = rect_masks\n        self.rect_time = rect_time\n        self.rect_freq = rect_freq\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.rect_masks):\n                rect_x = int(self._rng.uniform(\n                    0, sh[1] - self.rect_freq))\n                rect_y = int(self._rng.uniform(\n                    0, sh[2] - self.rect_time))\n\n                w_x = int(self._rng.uniform(0, self.rect_time))\n                w_y = int(self._rng.uniform(0, self.rect_freq))\n\n                mask[idx, rect_x:rect_x + w_x,\n                     rect_y:rect_y + w_y] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x", "C:\\Users\\wutlin\\OneDrive - Microsoft\\workspace\\DNNMatchingToolkit\\dataset\\nltk_data", [0], "-norm", "voxel", "PlotItemWBuffer", ["#", "Adapted", "from", "https://github.com/NVIDIA/NeMo/blob/r0.9/collections/nemo_asr/", "#", "Copyright", "(C)", "2020", "Xilinx", "(Giuseppe", "Franco)", "#", "Copyright", "(C)", "2019", "NVIDIA", "CORPORATION.", "#", "#", "All", "Rights", "Reserved.", "#", "#", "Licensed", "under", "the", "Apache", "License,", "Version", "2.0", "(the", "\"License\");", "#", "you", "may", "not", "use", "this", "file", "except", "in", "compliance", "with", "the", "License.", "#", "You", "may", "obtain", "a", "copy", "of", "the", "License", "at", "#", "#", "http://www.apache.org/licenses/LICENSE-2.0", "#", "#", "Unless", "required", "by", "applicable", "law", "or", "agreed", "to", "in", "writing,", "software", "#", "distributed", "under", "the", "License", "is", "distributed", "on", "an", "\"AS", "IS\"", "BASIS,", "#", "WITHOUT", "WARRANTIES", "OR", "CONDITIONS", "OF", "ANY", "KIND,", "either", "express", "or", "implied.", "#", "See", "the", "License", "for", "the", "specific", "language", "governing", "permissions", "and", "#", "limitations", "under", "the", "License.", "import", "random", "import", "torch", "import", "torch.nn", "as", "nn", "class", "SpecAugment(nn.Module):", "\"\"\"", "Zeroes", "out(cuts)", "random", "continuous", "horisontal", "or", "vertical", "segments", "of", "the", "spectrogram", "as", "described", "in", "SpecAugment", "(https://arxiv.org/abs/1904.08779).", "params:", "freq_masks", "-", "how", "many", "frequency", "segments", "should", "be", "cut", "time_masks", "-", "how", "many", "time", "segments", "should", "be", "cut", "freq_width", "-", "maximum", "number", "of", "frequencies", "to", "be", "cut", "in", "one", "segment", "time_width", "-", "maximum", "number", "of", "time", "steps", "to", "be", "cut", "in", "one", "segment", "\"\"\"", "def", "__init__(", "self,", "freq_masks=0,", "time_masks=0,", "freq_width=10,", "time_width=10,", "rng=None", "):", "super(SpecAugment,", "self).__init__()", "self._rng", "=", "random.Random()", "if", "rng", "is", "None", "else", "rng", "self.freq_masks", "=", "freq_masks", "self.time_masks", "=", "time_masks", "self.freq_width", "=", "freq_width", "self.time_width", "=", "time_width", "@torch.no_grad()", "def", "forward(self,", "x):", "sh", "=", "x.shape", "mask", "=", "torch.zeros(x.shape).byte()", "for", "idx", "in", "range(sh[0]):", "for", "i", "in", "range(self.freq_masks):", "x_left", "=", "int(self._rng.uniform(", "0,", "sh[1]", "-", "self.freq_width))", "w", "=", "int(self._rng.uniform(0,", "self.freq_width))", "mask[idx,", "x_left:x_left", "+", "w,", ":]", "=", "1", "for", "i", "in", "range(self.time_masks):", "y_left", "=", "int(self._rng.uniform(", "0,", "sh[2]", "-", "self.time_width))", "w", "=", "int(self._rng.uniform(0,", "self.time_width))", "mask[idx,", ":,", "y_left:y_left", "+", "w]", "=", "1", "x", "=", "x.masked_fill(mask.type(torch.bool).to(device=x.device),", "0)", "return", "x", "class", "SpecCutout(nn.Module):", "\"\"\"", "Zeroes", "out(cuts)", "random", "rectangles", "in", "the", "spectrogram", "as", "described", "in", "(https://arxiv.org/abs/1708.04552).", "params:", "rect_masks", "-", "how", "many", "rectangular", "masks", "should", "be", "cut", "rect_freq", "-", "maximum", "size", "of", "cut", "rectangles", "along", "the", "frequency", "dimension", "rect_time", "-", "maximum", "size", "of", "cut", "rectangles", "along", "the", "time", "dimension", "\"\"\"", "def", "__init__(", "self,", "rect_masks=0,", "rect_time=5,", "rect_freq=20,", "rng=None", "):", "super(SpecCutout,", "self).__init__()", "self._rng", "=", "random.Random()", "if", "rng", "is", "None", "else", "rng", "self.rect_masks", "=", "rect_masks", "self.rect_time", "=", "rect_time", "self.rect_freq", "=", "rect_freq", "@torch.no_grad()", "def", "forward(self,", "x):", "sh", "=", "x.shape", "mask", "=", "torch.zeros(x.shape).byte()", "for", "idx", "in", "range(sh[0]):", "for", "i", "in", "range(self.rect_masks):", "rect_x", "=", "int(self._rng.uniform(", "0,", "sh[1]", "-", "self.rect_freq))", "rect_y", "=", "int(self._rng.uniform(", "0,", "sh[2]", "-", "self.rect_time))", "w_x", "=", "int(self._rng.uniform(0,", "self.rect_time))", "w_y", "=", "int(self._rng.uniform(0,", "self.rect_freq))", "mask[idx,", "rect_x:rect_x", "+", "w_x,", "rect_y:rect_y", "+", "w_y]", "=", "1", "x", "=", "x.masked_fill(mask.type(torch.bool).to(device=x.device),", "0)", "return", "x"], "/usr/local/lib/python3.5/dist-packages", "../ocr", "/MP", ".cu", "<built-in function id>", ["# Adapted from https://github.com/NVIDIA/NeMo/blob/r0.9/collections/nemo_asr/\n# Copyright (C) 2020 Xilinx (Giuseppe Franco)\n# Copyright (C) 2019 NVIDIA CORPORATION.\n#\n# All Rights Reserved.\n#\n# Licensed under the Apache License", " Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing", " software\n# distributed under the License is distributed on an \"AS IS\" BASIS", "\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND", " either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport random\n\nimport torch\nimport torch.nn as nn\n\n\nclass SpecAugment(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random continuous horisontal or\n    vertical segments of the spectrogram as described in\n    SpecAugment (https://arxiv.org/abs/1904.08779).\n\n    params:\n    freq_masks - how many frequency segments should be cut\n    time_masks - how many time segments should be cut\n    freq_width - maximum number of frequencies to be cut in one segment\n    time_width - maximum number of time steps to be cut in one segment\n    \"\"\"\n    def __init__(\n        self", "\n        freq_masks=0", "\n        time_masks=0", "\n        freq_width=10", "\n        time_width=10", "\n        rng=None\n    ):\n        super(SpecAugment", " self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.freq_masks = freq_masks\n        self.time_masks = time_masks\n\n        self.freq_width = freq_width\n        self.time_width = time_width\n\n    @torch.no_grad()\n    def forward(self", " x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.freq_masks):\n                x_left = int(self._rng.uniform(\n                    0", " sh[1] - self.freq_width))\n\n                w = int(self._rng.uniform(0", " self.freq_width))\n\n                mask[idx", " x_left:x_left + w", " :] = 1\n\n            for i in range(self.time_masks):\n                y_left = int(self._rng.uniform(\n                    0", " sh[2] - self.time_width))\n\n                w = int(self._rng.uniform(0", " self.time_width))\n\n                mask[idx", " :", "\n                     y_left:y_left + w] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device)", " 0)\n\n        return x\n\n\nclass SpecCutout(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random rectangles in the spectrogram\n    as described in (https://arxiv.org/abs/1708.04552).\n\n    params:\n    rect_masks - how many rectangular masks should be cut\n    rect_freq - maximum size of cut rectangles along the frequency dimension\n    rect_time - maximum size of cut rectangles along the time dimension\n    \"\"\"\n    def __init__(\n        self", "\n        rect_masks=0", "\n        rect_time=5", "\n        rect_freq=20", "\n        rng=None\n    ):\n        super(SpecCutout", " self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.rect_masks = rect_masks\n        self.rect_time = rect_time\n        self.rect_freq = rect_freq\n\n    @torch.no_grad()\n    def forward(self", " x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.rect_masks):\n                rect_x = int(self._rng.uniform(\n                    0", " sh[1] - self.rect_freq))\n                rect_y = int(self._rng.uniform(\n                    0", " sh[2] - self.rect_time))\n\n                w_x = int(self._rng.uniform(0", " self.rect_time))\n                w_y = int(self._rng.uniform(0", " self.rect_freq))\n\n                mask[idx", " rect_x:rect_x + w_x", "\n                     rect_y:rect_y + w_y] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device)", " 0)\n\n        return x"], "/home/blue/Documents/api-representation-learning", "fwd", "node_0", "noall", ["# Adapted from https://github.com/NVIDIA/NeMo/blob/r0.9/collections/nemo_asr/\n# Copyright (C) 2020 Xilinx (Giuseppe Franco)\n# Copyright (C) 2019 NVIDIA CORPORATION.\n#\n# All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport random\n\nimport torch\nimport torch.nn as nn\n\n\nclass SpecAugment(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random continuous horisontal or\n    vertical segments of the spectrogram as described in\n    SpecAugment (https://arxiv.org/abs/1904.08779).\n\n    params:\n    freq_masks - how many frequency segments should be cut\n    time_masks - how many time segments should be cut\n    freq_width - maximum number of frequencies to be cut in one segment\n    time_width - maximum number of time steps to be cut in one segment\n    \"\"\"\n    def __init__(\n        self,\n        freq_masks=0,\n        time_masks=0,\n        freq_width=10,\n        time_width=10,\n        rng=None\n    ):\n        super(SpecAugment, self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.freq_masks = freq_masks\n        self.time_masks = time_masks\n\n        self.freq_width = freq_width\n        self.time_width = time_width\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.freq_masks):\n                x_left = int(self._rng.uniform(\n                    0, sh[1] - self.freq_width))\n\n                w = int(self._rng.uniform(0, self.freq_width))\n\n                mask[idx, x_left:x_left + w, :] = 1\n\n            for i in range(self.time_masks):\n                y_left = int(self._rng.uniform(\n                    0, sh[2] - self.time_width))\n\n                w = int(self._rng.uniform(0, self.time_width))\n\n                mask[idx, :,\n                     y_left:y_left + w] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x\n\n\nclass SpecCutout(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random rectangles in the spectrogram\n    as described in (https://arxiv.org/abs/1708.04552).\n\n    params:\n    rect_masks - how many rectangular masks should be cut\n    rect_freq - maximum size of cut rectangles along the frequency dimension\n    rect_time - maximum size of cut rectangles along the time dimension\n    \"\"\"\n    def __init__(\n        self,\n        rect_masks=0,\n        rect_time=5,\n        rect_freq=20,\n        rng=None\n    ):\n        super(SpecCutout, self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.rect_masks = rect_masks\n        self.rect_time = rect_time\n        self.rect_freq = rect_freq\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.rect_masks):\n                rect_x = int(self._rng.uniform(\n                    0, sh[1] - self.rect_freq))\n                rect_y = int(self._rng.uniform(\n                    0, sh[2] - self.rect_time))\n\n                w_x = int(self._rng.uniform(0, self.rect_time))\n                w_y = int(self._rng.uniform(0, self.rect_freq))\n\n                mask[idx, rect_x:rect_x + w_x,\n                     rect_y:rect_y + w_y] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x\n"], "arm-down", "/home/blue/Documents/api-representation-learning/commons/..", "-mca plm_rsh_no_tree_spawn true", "/tmp/models/slim", "/home/blue/Documents/api-representation-learning/commons/./.github/workflows", "[CLS]", "G_3D", "../../", ["cupy", "6.0.0"], "/home/chenliu/Projects/PlaneNet/code", "PairWavDataset", "/home/blue/Documents", [true], "#", "../../../", "main/acc_asr", "php", "detector/YOLOv3", "sphinxcontrib.spelling", "/home/xiaohang/caffe/python", "resulting dataframe has unexpected shape.", "/home/blue/Documents/api-representation-learning/commons/../src", "/u/subramas/Research/nmt-pytorch", "GruBinarizer/SignBinarizer/Sign_0:0", "cusparse", ["train/unsup", 0], "../python/addons", "<eos>", "models/slim", ".combined.png", "./auxiliary/netvision/", "../DeepSpeedExamples/Megatron_GPT2", "--use_istio", "oracle_ensemble", "<EOS>", [true, false], "model", "/home/blue/Documents/api-representation-learning/helpers", "clip", "/home/blue/Documents/api-representation-learning/commons/../DIB-R", "--world-size", "mAP", "./src", "-DHAVE_ZLIB", "--verbose", "year_lin", "guzzle_sphinx_theme", "--debug", null, "total_loss", "../pytorch_Realtime_Multi-Person_Pose_Estimation", "--noauth_local_webserver", "../github_crawler/torch_pyfiles", 255, "pycocotools", "im_names", "../build", "../../../DeepSpeedExamples/BingBertSquad", [[], [], [], [], [], [], [], []], "v0", "# Adapted from https://github.com/NVIDIA/NeMo/blob/r0.9/collections/nemo_asr/\n# Copyright (C) 2020 Xilinx (Giuseppe Franco)\n# Copyright (C) 2019 NVIDIA CORPORATION.\n#\n# All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport random\n\nimport torch\nimport torch.nn as nn\n\n\nclass SpecAugment(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random continuous horisontal or\n    vertical segments of the spectrogram as described in\n    SpecAugment (https://arxiv.org/abs/1904.08779).\n\n    params:\n    freq_masks - how many frequency segments should be cut\n    time_masks - how many time segments should be cut\n    freq_width - maximum number of frequencies to be cut in one segment\n    time_width - maximum number of time steps to be cut in one segment\n    \"\"\"\n    def __init__(\n        self,\n        freq_masks=0,\n        time_masks=0,\n        freq_width=10,\n        time_width=10,\n        rng=None\n    ):\n        super(SpecAugment, self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.freq_masks = freq_masks\n        self.time_masks = time_masks\n\n        self.freq_width = freq_width\n        self.time_width = time_width\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.freq_masks):\n                x_left = int(self._rng.uniform(\n                    0, sh[1] - self.freq_width))\n\n                w = int(self._rng.uniform(0, self.freq_width))\n\n                mask[idx, x_left:x_left + w, :] = 1\n\n            for i in range(self.time_masks):\n                y_left = int(self._rng.uniform(\n                    0, sh[2] - self.time_width))\n\n                w = int(self._rng.uniform(0, self.time_width))\n\n                mask[idx, :,\n                     y_left:y_left + w] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x\n\n\nclass SpecCutout(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random rectangles in the spectrogram\n    as described in (https://arxiv.org/abs/1708.04552).\n\n    params:\n    rect_masks - how many rectangular masks should be cut\n    rect_freq - maximum size of cut rectangles along the frequency dimension\n    rect_time - maximum size of cut rectangles along the time dimension\n    \"\"\"\n    def __init__(\n        self,\n        rect_masks=0,\n        rect_time=5,\n        rect_freq=20,\n        rng=None\n    ):\n        super(SpecCutout, self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.rect_masks = rect_masks\n        self.rect_time = rect_time\n        self.rect_freq = rect_freq\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.rect_masks):\n                rect_x = int(self._rng.uniform(\n                    0, sh[1] - self.rect_freq))\n                rect_y = int(self._rng.uniform(\n                    0, sh[2] - self.rect_time))\n\n                w_x = int(self._rng.uniform(0, self.rect_time))\n                w_y = int(self._rng.uniform(0, self.rect_freq))\n\n                mask[idx, rect_x:rect_x + w_x,\n                     rect_y:rect_y + w_y] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x", "Atari", "<UNK>", "/gpfs01/bethge/home/sschneider/thesis/code/domainadaptation/", "delimiters", "random_color", "time", "../semi-supervised", "./partition/cut-pursuit/build/src", "cuda", "G_local", "fixed_input_0", "/home/blue/Documents/api-representation-learning/commons/../..", "--include-package", "./partition/", "./", "CometLogger", Infinity, "/home/blue/Documents/api-representation-learning/commons/progress", "alpha", "models/research/slim", "vqa/external/pretrained-models.pytorch", "gt_bboxes_ignore", "PlotDataset", "torch_optimizer", "../demos", "--cuda", "__weights_dict", "-e", "/home/fregu856/3DOD_thesis/Open3D/build/lib", "pyredner", "test", "../", ["sess.run(output, feed_dict", "feed_dict)"], "--delete", "/u/subramas/Research/nmt-pytorch/", "value", "-DNGRAPH_ONNX_IMPORT_ENABLE", "log_learning_rate", "..", "/home/erogol/Projects", "dali-gpu", "-h", "momentum_buffer", "/private/home/ronghanghu/workspace/vqa-maskrcnn-benchmark", "</s>", "critic_net", "TQDMProgressBar", "--jpath", "weight/yolov4.pb", [], "accuracy_score", ["d", 1], "../github_crawler/torch_pyfiles/Xilinx__brevitas", "/root/deeplabv3", "y_range", "pruning", "correlation_cuda_kernel.cu", "null", "game/", "classifier", "fc", [[".", "."], [".", "/"], ["/", "g"], ["g", "i"], ["i", "t"], ["t", "h"], ["h", "u"], ["u", "b"], ["b", "_"], ["_", "c"], ["c", "r"], ["r", "a"], ["a", "w"], ["w", "l"], ["l", "e"], ["e", "r"], ["r", "/"], ["/", "t"], ["t", "o"], ["o", "r"], ["r", "c"], ["c", "h"], ["h", "_"], ["_", "p"], ["p", "y"], ["y", "f"], ["f", "i"], ["i", "l"], ["l", "e"], ["e", "s"]], 410, "'", ["#", " ", "A", "d", "a", "p", "t", "e", "d", " ", "f", "r", "o", "m", " ", "h", "t", "t", "p", "s", ":", "/", "/", "g", "i", "t", "h", "u", "b", ".", "c", "o", "m", "/", "N", "V", "I", "D", "I", "A", "/", "N", "e", "M", "o", "/", "b", "l", "o", "b", "/", "r", "0", ".", "9", "/", "c", "o", "l", "l", "e", "c", "t", "i", "o", "n", "s", "/", "n", "e", "m", "o", "_", "a", "s", "r", "/", "\n", "#", " ", "C", "o", "p", "y", "r", "i", "g", "h", "t", " ", "(", "C", ")", " ", "2", "0", "2", "0", " ", "X", "i", "l", "i", "n", "x", " ", "(", "G", "i", "u", "s", "e", "p", "p", "e", " ", "F", "r", "a", "n", "c", "o", ")", "\n", "#", " ", "C", "o", "p", "y", "r", "i", "g", "h", "t", " ", "(", "C", ")", " ", "2", "0", "1", "9", " ", "N", "V", "I", "D", "I", "A", " ", "C", "O", "R", "P", "O", "R", "A", "T", "I", "O", "N", ".", "\n", "#", "\n", "#", " ", "A", "l", "l", " ", "R", "i", "g", "h", "t", "s", " ", "R", "e", "s", "e", "r", "v", "e", "d", ".", "\n", "#", "\n", "#", " ", "L", "i", "c", "e", "n", "s", "e", "d", " ", "u", "n", "d", "e", "r", " ", "t", "h", "e", " ", "A", "p", "a", "c", "h", "e", " ", "L", "i", "c", "e", "n", "s", "e", ",", " ", "V", "e", "r", "s", "i", "o", "n", " ", "2", ".", "0", " ", "(", "t", "h", "e", " ", "\"", "L", "i", "c", "e", "n", "s", "e", "\"", ")", ";", "\n", "#", " ", "y", "o", "u", " ", "m", "a", "y", " ", "n", "o", "t", " ", "u", "s", "e", " ", "t", "h", "i", "s", " ", "f", "i", "l", "e", " ", "e", "x", "c", "e", "p", "t", " ", "i", "n", " ", "c", "o", "m", "p", "l", "i", "a", "n", "c", "e", " ", "w", "i", "t", "h", " ", "t", "h", "e", " ", "L", "i", "c", "e", "n", "s", "e", ".", "\n", "#", " ", "Y", "o", "u", " ", "m", "a", "y", " ", "o", "b", "t", "a", "i", "n", " ", "a", " ", "c", "o", "p", "y", " ", "o", "f", " ", "t", "h", "e", " ", "L", "i", "c", "e", "n", "s", "e", " ", "a", "t", "\n", "#", "\n", "#", " ", " ", " ", " ", " ", " ", "h", "t", "t", "p", ":", "/", "/", "w", "w", "w", ".", "a", "p", "a", "c", "h", "e", ".", "o", "r", "g", "/", "l", "i", "c", "e", "n", "s", "e", "s", "/", "L", "I", "C", "E", "N", "S", "E", "-", "2", ".", "0", "\n", "#", "\n", "#", " ", "U", "n", "l", "e", "s", "s", " ", "r", "e", "q", "u", "i", "r", "e", "d", " ", "b", "y", " ", "a", "p", "p", "l", "i", "c", "a", "b", "l", "e", " ", "l", "a", "w", " ", "o", "r", " ", "a", "g", "r", "e", "e", "d", " ", "t", "o", " ", "i", "n", " ", "w", "r", "i", "t", "i", "n", "g", ",", " ", "s", "o", "f", "t", "w", "a", "r", "e", "\n", "#", " ", "d", "i", "s", "t", "r", "i", "b", "u", "t", "e", "d", " ", "u", "n", "d", "e", "r", " ", "t", "h", "e", " ", "L", "i", "c", "e", "n", "s", "e", " ", "i", "s", " ", "d", "i", "s", "t", "r", "i", "b", "u", "t", "e", "d", " ", "o", "n", " ", "a", "n", " ", "\"", "A", "S", " ", "I", "S", "\"", " ", "B", "A", "S", "I", "S", ",", "\n", "#", " ", "W", "I", "T", "H", "O", "U", "T", " ", "W", "A", "R", "R", "A", "N", "T", "I", "E", "S", " ", "O", "R", " ", "C", "O", "N", "D", "I", "T", "I", "O", "N", "S", " ", "O", "F", " ", "A", "N", "Y", " ", "K", "I", "N", "D", ",", " ", "e", "i", "t", "h", "e", "r", " ", "e", "x", "p", "r", "e", "s", "s", " ", "o", "r", " ", "i", "m", "p", "l", "i", "e", "d", ".", "\n", "#", " ", "S", "e", "e", " ", "t", "h", "e", " ", "L", "i", "c", "e", "n", "s", "e", " ", "f", "o", "r", " ", "t", "h", "e", " ", "s", "p", "e", "c", "i", "f", "i", "c", " ", "l", "a", "n", "g", "u", "a", "g", "e", " ", "g", "o", "v", "e", "r", "n", "i", "n", "g", " ", "p", "e", "r", "m", "i", "s", "s", "i", "o", "n", "s", " ", "a", "n", "d", "\n", "#", " ", "l", "i", "m", "i", "t", "a", "t", "i", "o", "n", "s", " ", "u", "n", "d", "e", "r", " ", "t", "h", "e", " ", "L", "i", "c", "e", "n", "s", "e", ".", "\n", "\n", "i", "m", "p", "o", "r", "t", " ", "r", "a", "n", "d", "o", "m", "\n", "\n", "i", "m", "p", "o", "r", "t", " ", "t", "o", "r", "c", "h", "\n", "i", "m", "p", "o", "r", "t", " ", "t", "o", "r", "c", "h", ".", "n", "n", " ", "a", "s", " ", "n", "n", "\n", "\n", "\n", "c", "l", "a", "s", "s", " ", "S", "p", "e", "c", "A", "u", "g", "m", "e", "n", "t", "(", "n", "n", ".", "M", "o", "d", "u", "l", "e", ")", ":", "\n", " ", " ", " ", " ", "\"", "\"", "\"", "\n", " ", " ", " ", " ", "Z", "e", "r", "o", "e", "s", " ", "o", "u", "t", "(", "c", "u", "t", "s", ")", " ", "r", "a", "n", "d", "o", "m", " ", "c", "o", "n", "t", "i", "n", "u", "o", "u", "s", " ", "h", "o", "r", "i", "s", "o", "n", "t", "a", "l", " ", "o", "r", "\n", " ", " ", " ", " ", "v", "e", "r", "t", "i", "c", "a", "l", " ", "s", "e", "g", "m", "e", "n", "t", "s", " ", "o", "f", " ", "t", "h", "e", " ", "s", "p", "e", "c", "t", "r", "o", "g", "r", "a", "m", " ", "a", "s", " ", "d", "e", "s", "c", "r", "i", "b", "e", "d", " ", "i", "n", "\n", " ", " ", " ", " ", "S", "p", "e", "c", "A", "u", "g", "m", "e", "n", "t", " ", "(", "h", "t", "t", "p", "s", ":", "/", "/", "a", "r", "x", "i", "v", ".", "o", "r", "g", "/", "a", "b", "s", "/", "1", "9", "0", "4", ".", "0", "8", "7", "7", "9", ")", ".", "\n", "\n", " ", " ", " ", " ", "p", "a", "r", "a", "m", "s", ":", "\n", " ", " ", " ", " ", "f", "r", "e", "q", "_", "m", "a", "s", "k", "s", " ", "-", " ", "h", "o", "w", " ", "m", "a", "n", "y", " ", "f", "r", "e", "q", "u", "e", "n", "c", "y", " ", "s", "e", "g", "m", "e", "n", "t", "s", " ", "s", "h", "o", "u", "l", "d", " ", "b", "e", " ", "c", "u", "t", "\n", " ", " ", " ", " ", "t", "i", "m", "e", "_", "m", "a", "s", "k", "s", " ", "-", " ", "h", "o", "w", " ", "m", "a", "n", "y", " ", "t", "i", "m", "e", " ", "s", "e", "g", "m", "e", "n", "t", "s", " ", "s", "h", "o", "u", "l", "d", " ", "b", "e", " ", "c", "u", "t", "\n", " ", " ", " ", " ", "f", "r", "e", "q", "_", "w", "i", "d", "t", "h", " ", "-", " ", "m", "a", "x", "i", "m", "u", "m", " ", "n", "u", "m", "b", "e", "r", " ", "o", "f", " ", "f", "r", "e", "q", "u", "e", "n", "c", "i", "e", "s", " ", "t", "o", " ", "b", "e", " ", "c", "u", "t", " ", "i", "n", " ", "o", "n", "e", " ", "s", "e", "g", "m", "e", "n", "t", "\n", " ", " ", " ", " ", "t", "i", "m", "e", "_", "w", "i", "d", "t", "h", " ", "-", " ", "m", "a", "x", "i", "m", "u", "m", " ", "n", "u", "m", "b", "e", "r", " ", "o", "f", " ", "t", "i", "m", "e", " ", "s", "t", "e", "p", "s", " ", "t", "o", " ", "b", "e", " ", "c", "u", "t", " ", "i", "n", " ", "o", "n", "e", " ", "s", "e", "g", "m", "e", "n", "t", "\n", " ", " ", " ", " ", "\"", "\"", "\"", "\n", " ", " ", " ", " ", "d", "e", "f", " ", "_", "_", "i", "n", "i", "t", "_", "_", "(", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "f", "r", "e", "q", "_", "m", "a", "s", "k", "s", "=", "0", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "t", "i", "m", "e", "_", "m", "a", "s", "k", "s", "=", "0", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "f", "r", "e", "q", "_", "w", "i", "d", "t", "h", "=", "1", "0", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "t", "i", "m", "e", "_", "w", "i", "d", "t", "h", "=", "1", "0", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "r", "n", "g", "=", "N", "o", "n", "e", "\n", " ", " ", " ", " ", ")", ":", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "u", "p", "e", "r", "(", "S", "p", "e", "c", "A", "u", "g", "m", "e", "n", "t", ",", " ", "s", "e", "l", "f", ")", ".", "_", "_", "i", "n", "i", "t", "_", "_", "(", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ".", "_", "r", "n", "g", " ", "=", " ", "r", "a", "n", "d", "o", "m", ".", "R", "a", "n", "d", "o", "m", "(", ")", " ", "i", "f", " ", "r", "n", "g", " ", "i", "s", " ", "N", "o", "n", "e", " ", "e", "l", "s", "e", " ", "r", "n", "g", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ".", "f", "r", "e", "q", "_", "m", "a", "s", "k", "s", " ", "=", " ", "f", "r", "e", "q", "_", "m", "a", "s", "k", "s", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ".", "t", "i", "m", "e", "_", "m", "a", "s", "k", "s", " ", "=", " ", "t", "i", "m", "e", "_", "m", "a", "s", "k", "s", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ".", "f", "r", "e", "q", "_", "w", "i", "d", "t", "h", " ", "=", " ", "f", "r", "e", "q", "_", "w", "i", "d", "t", "h", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ".", "t", "i", "m", "e", "_", "w", "i", "d", "t", "h", " ", "=", " ", "t", "i", "m", "e", "_", "w", "i", "d", "t", "h", "\n", "\n", " ", " ", " ", " ", "@", "t", "o", "r", "c", "h", ".", "n", "o", "_", "g", "r", "a", "d", "(", ")", "\n", " ", " ", " ", " ", "d", "e", "f", " ", "f", "o", "r", "w", "a", "r", "d", "(", "s", "e", "l", "f", ",", " ", "x", ")", ":", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "h", " ", "=", " ", "x", ".", "s", "h", "a", "p", "e", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "m", "a", "s", "k", " ", "=", " ", "t", "o", "r", "c", "h", ".", "z", "e", "r", "o", "s", "(", "x", ".", "s", "h", "a", "p", "e", ")", ".", "b", "y", "t", "e", "(", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "f", "o", "r", " ", "i", "d", "x", " ", "i", "n", " ", "r", "a", "n", "g", "e", "(", "s", "h", "[", "0", "]", ")", ":", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "f", "o", "r", " ", "i", " ", "i", "n", " ", "r", "a", "n", "g", "e", "(", "s", "e", "l", "f", ".", "f", "r", "e", "q", "_", "m", "a", "s", "k", "s", ")", ":", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "x", "_", "l", "e", "f", "t", " ", "=", " ", "i", "n", "t", "(", "s", "e", "l", "f", ".", "_", "r", "n", "g", ".", "u", "n", "i", "f", "o", "r", "m", "(", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "0", ",", " ", "s", "h", "[", "1", "]", " ", "-", " ", "s", "e", "l", "f", ".", "f", "r", "e", "q", "_", "w", "i", "d", "t", "h", ")", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "w", " ", "=", " ", "i", "n", "t", "(", "s", "e", "l", "f", ".", "_", "r", "n", "g", ".", "u", "n", "i", "f", "o", "r", "m", "(", "0", ",", " ", "s", "e", "l", "f", ".", "f", "r", "e", "q", "_", "w", "i", "d", "t", "h", ")", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "m", "a", "s", "k", "[", "i", "d", "x", ",", " ", "x", "_", "l", "e", "f", "t", ":", "x", "_", "l", "e", "f", "t", " ", "+", " ", "w", ",", " ", ":", "]", " ", "=", " ", "1", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "f", "o", "r", " ", "i", " ", "i", "n", " ", "r", "a", "n", "g", "e", "(", "s", "e", "l", "f", ".", "t", "i", "m", "e", "_", "m", "a", "s", "k", "s", ")", ":", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "y", "_", "l", "e", "f", "t", " ", "=", " ", "i", "n", "t", "(", "s", "e", "l", "f", ".", "_", "r", "n", "g", ".", "u", "n", "i", "f", "o", "r", "m", "(", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "0", ",", " ", "s", "h", "[", "2", "]", " ", "-", " ", "s", "e", "l", "f", ".", "t", "i", "m", "e", "_", "w", "i", "d", "t", "h", ")", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "w", " ", "=", " ", "i", "n", "t", "(", "s", "e", "l", "f", ".", "_", "r", "n", "g", ".", "u", "n", "i", "f", "o", "r", "m", "(", "0", ",", " ", "s", "e", "l", "f", ".", "t", "i", "m", "e", "_", "w", "i", "d", "t", "h", ")", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "m", "a", "s", "k", "[", "i", "d", "x", ",", " ", ":", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "y", "_", "l", "e", "f", "t", ":", "y", "_", "l", "e", "f", "t", " ", "+", " ", "w", "]", " ", "=", " ", "1", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "x", " ", "=", " ", "x", ".", "m", "a", "s", "k", "e", "d", "_", "f", "i", "l", "l", "(", "m", "a", "s", "k", ".", "t", "y", "p", "e", "(", "t", "o", "r", "c", "h", ".", "b", "o", "o", "l", ")", ".", "t", "o", "(", "d", "e", "v", "i", "c", "e", "=", "x", ".", "d", "e", "v", "i", "c", "e", ")", ",", " ", "0", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "r", "e", "t", "u", "r", "n", " ", "x", "\n", "\n", "\n", "c", "l", "a", "s", "s", " ", "S", "p", "e", "c", "C", "u", "t", "o", "u", "t", "(", "n", "n", ".", "M", "o", "d", "u", "l", "e", ")", ":", "\n", " ", " ", " ", " ", "\"", "\"", "\"", "\n", " ", " ", " ", " ", "Z", "e", "r", "o", "e", "s", " ", "o", "u", "t", "(", "c", "u", "t", "s", ")", " ", "r", "a", "n", "d", "o", "m", " ", "r", "e", "c", "t", "a", "n", "g", "l", "e", "s", " ", "i", "n", " ", "t", "h", "e", " ", "s", "p", "e", "c", "t", "r", "o", "g", "r", "a", "m", "\n", " ", " ", " ", " ", "a", "s", " ", "d", "e", "s", "c", "r", "i", "b", "e", "d", " ", "i", "n", " ", "(", "h", "t", "t", "p", "s", ":", "/", "/", "a", "r", "x", "i", "v", ".", "o", "r", "g", "/", "a", "b", "s", "/", "1", "7", "0", "8", ".", "0", "4", "5", "5", "2", ")", ".", "\n", "\n", " ", " ", " ", " ", "p", "a", "r", "a", "m", "s", ":", "\n", " ", " ", " ", " ", "r", "e", "c", "t", "_", "m", "a", "s", "k", "s", " ", "-", " ", "h", "o", "w", " ", "m", "a", "n", "y", " ", "r", "e", "c", "t", "a", "n", "g", "u", "l", "a", "r", " ", "m", "a", "s", "k", "s", " ", "s", "h", "o", "u", "l", "d", " ", "b", "e", " ", "c", "u", "t", "\n", " ", " ", " ", " ", "r", "e", "c", "t", "_", "f", "r", "e", "q", " ", "-", " ", "m", "a", "x", "i", "m", "u", "m", " ", "s", "i", "z", "e", " ", "o", "f", " ", "c", "u", "t", " ", "r", "e", "c", "t", "a", "n", "g", "l", "e", "s", " ", "a", "l", "o", "n", "g", " ", "t", "h", "e", " ", "f", "r", "e", "q", "u", "e", "n", "c", "y", " ", "d", "i", "m", "e", "n", "s", "i", "o", "n", "\n", " ", " ", " ", " ", "r", "e", "c", "t", "_", "t", "i", "m", "e", " ", "-", " ", "m", "a", "x", "i", "m", "u", "m", " ", "s", "i", "z", "e", " ", "o", "f", " ", "c", "u", "t", " ", "r", "e", "c", "t", "a", "n", "g", "l", "e", "s", " ", "a", "l", "o", "n", "g", " ", "t", "h", "e", " ", "t", "i", "m", "e", " ", "d", "i", "m", "e", "n", "s", "i", "o", "n", "\n", " ", " ", " ", " ", "\"", "\"", "\"", "\n", " ", " ", " ", " ", "d", "e", "f", " ", "_", "_", "i", "n", "i", "t", "_", "_", "(", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "r", "e", "c", "t", "_", "m", "a", "s", "k", "s", "=", "0", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "r", "e", "c", "t", "_", "t", "i", "m", "e", "=", "5", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "r", "e", "c", "t", "_", "f", "r", "e", "q", "=", "2", "0", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "r", "n", "g", "=", "N", "o", "n", "e", "\n", " ", " ", " ", " ", ")", ":", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "u", "p", "e", "r", "(", "S", "p", "e", "c", "C", "u", "t", "o", "u", "t", ",", " ", "s", "e", "l", "f", ")", ".", "_", "_", "i", "n", "i", "t", "_", "_", "(", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ".", "_", "r", "n", "g", " ", "=", " ", "r", "a", "n", "d", "o", "m", ".", "R", "a", "n", "d", "o", "m", "(", ")", " ", "i", "f", " ", "r", "n", "g", " ", "i", "s", " ", "N", "o", "n", "e", " ", "e", "l", "s", "e", " ", "r", "n", "g", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ".", "r", "e", "c", "t", "_", "m", "a", "s", "k", "s", " ", "=", " ", "r", "e", "c", "t", "_", "m", "a", "s", "k", "s", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ".", "r", "e", "c", "t", "_", "t", "i", "m", "e", " ", "=", " ", "r", "e", "c", "t", "_", "t", "i", "m", "e", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ".", "r", "e", "c", "t", "_", "f", "r", "e", "q", " ", "=", " ", "r", "e", "c", "t", "_", "f", "r", "e", "q", "\n", "\n", " ", " ", " ", " ", "@", "t", "o", "r", "c", "h", ".", "n", "o", "_", "g", "r", "a", "d", "(", ")", "\n", " ", " ", " ", " ", "d", "e", "f", " ", "f", "o", "r", "w", "a", "r", "d", "(", "s", "e", "l", "f", ",", " ", "x", ")", ":", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "h", " ", "=", " ", "x", ".", "s", "h", "a", "p", "e", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "m", "a", "s", "k", " ", "=", " ", "t", "o", "r", "c", "h", ".", "z", "e", "r", "o", "s", "(", "x", ".", "s", "h", "a", "p", "e", ")", ".", "b", "y", "t", "e", "(", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "f", "o", "r", " ", "i", "d", "x", " ", "i", "n", " ", "r", "a", "n", "g", "e", "(", "s", "h", "[", "0", "]", ")", ":", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "f", "o", "r", " ", "i", " ", "i", "n", " ", "r", "a", "n", "g", "e", "(", "s", "e", "l", "f", ".", "r", "e", "c", "t", "_", "m", "a", "s", "k", "s", ")", ":", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "r", "e", "c", "t", "_", "x", " ", "=", " ", "i", "n", "t", "(", "s", "e", "l", "f", ".", "_", "r", "n", "g", ".", "u", "n", "i", "f", "o", "r", "m", "(", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "0", ",", " ", "s", "h", "[", "1", "]", " ", "-", " ", "s", "e", "l", "f", ".", "r", "e", "c", "t", "_", "f", "r", "e", "q", ")", ")", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "r", "e", "c", "t", "_", "y", " ", "=", " ", "i", "n", "t", "(", "s", "e", "l", "f", ".", "_", "r", "n", "g", ".", "u", "n", "i", "f", "o", "r", "m", "(", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "0", ",", " ", "s", "h", "[", "2", "]", " ", "-", " ", "s", "e", "l", "f", ".", "r", "e", "c", "t", "_", "t", "i", "m", "e", ")", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "w", "_", "x", " ", "=", " ", "i", "n", "t", "(", "s", "e", "l", "f", ".", "_", "r", "n", "g", ".", "u", "n", "i", "f", "o", "r", "m", "(", "0", ",", " ", "s", "e", "l", "f", ".", "r", "e", "c", "t", "_", "t", "i", "m", "e", ")", ")", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "w", "_", "y", " ", "=", " ", "i", "n", "t", "(", "s", "e", "l", "f", ".", "_", "r", "n", "g", ".", "u", "n", "i", "f", "o", "r", "m", "(", "0", ",", " ", "s", "e", "l", "f", ".", "r", "e", "c", "t", "_", "f", "r", "e", "q", ")", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "m", "a", "s", "k", "[", "i", "d", "x", ",", " ", "r", "e", "c", "t", "_", "x", ":", "r", "e", "c", "t", "_", "x", " ", "+", " ", "w", "_", "x", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "r", "e", "c", "t", "_", "y", ":", "r", "e", "c", "t", "_", "y", " ", "+", " ", "w", "_", "y", "]", " ", "=", " ", "1", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "x", " ", "=", " ", "x", ".", "m", "a", "s", "k", "e", "d", "_", "f", "i", "l", "l", "(", "m", "a", "s", "k", ".", "t", "y", "p", "e", "(", "t", "o", "r", "c", "h", ".", "b", "o", "o", "l", ")", ".", "t", "o", "(", "d", "e", "v", "i", "c", "e", "=", "x", ".", "d", "e", "v", "i", "c", "e", ")", ",", " ", "0", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "r", "e", "t", "u", "r", "n", " ", "x", "\n"], "TensorboardLogger", "eps", "https://download.pytorch.org/whl/torch_stable.html", "{}]", "/root/deeplabv3/model", "utils", "s", "models/", "depth_minmax", [0, "[SEP]"], "-m", "./learning", "/path/to/caffe/python", "reporting_basedir_handler", "../..", "...", "data", [0, 0], "/root/inst/bin/", "minor_number", "error: the setup output does not match the intended input", "/home/blue/Documents/api-representation-learning/commons/models/detectors/yolo", "../src", "./pretrain/pytorch/", [0, 0, 0], "vqa/external/skip-thoughts.torch/pytorch", "./models", "../PNASNet.TF", "\t", "0/0", "tagger", ".", "DT", [1602589777.7500007, "../github_crawler/torch_pyfiles"], ["# adapted from https://github.com/nvidia/nemo/blob/r0.9/collections/nemo_asr/\n# copyright (c) 2020 xilinx (giuseppe franco)\n# copyright (c) 2019 nvidia corporation.\n#\n# all rights reserved.\n#\n# licensed under the apache license, version 2.0 (the \"license\");\n# you may not use this file except in compliance with the license.\n# you may obtain a copy of the license at\n#\n#      http://www.apache.org/licenses/license-2.0\n#\n# unless required by applicable law or agreed to in writing, software\n# distributed under the license is distributed on an \"as is\" basis,\n# without warranties or conditions of any kind, either express or implied.\n# see the license for the specific language governing permissions and\n# limitations under the license.\n\nimport random\n\nimport torch\nimport torch.nn as nn\n\n\nclass specaugment(nn.module):\n    \"\"\"\n    zeroes out(cuts) random continuous horisontal or\n    vertical segments of the spectrogram as described in\n    specaugment (https://arxiv.org/abs/1904.08779).\n\n    params:\n    freq_masks - how many frequency segments should be cut\n    time_masks - how many time segments should be cut\n    freq_width - maximum number of frequencies to be cut in one segment\n    time_width - maximum number of time steps to be cut in one segment\n    \"\"\"\n    def __init__(\n        self,\n        freq_masks=0,\n        time_masks=0,\n        freq_width=10,\n        time_width=10,\n        rng=none\n    ):\n        super(specaugment, self).__init__()\n\n        self._rng = random.random() if rng is none else rng\n\n        self.freq_masks = freq_masks\n        self.time_masks = time_masks\n\n        self.freq_width = freq_width\n        self.time_width = time_width\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.freq_masks):\n                x_left = int(self._rng.uniform(\n                    0, sh[1] - self.freq_width))\n\n                w = int(self._rng.uniform(0, self.freq_width))\n\n                mask[idx, x_left:x_left + w, :] = 1\n\n            for i in range(self.time_masks):\n                y_left = int(self._rng.uniform(\n                    0, sh[2] - self.time_width))\n\n                w = int(self._rng.uniform(0, self.time_width))\n\n                mask[idx, :,\n                     y_left:y_left + w] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x\n\n\nclass speccutout(nn.module):\n    \"\"\"\n    zeroes out(cuts) random rectangles in the spectrogram\n    as described in (https://arxiv.org/abs/1708.04552).\n\n    params:\n    rect_masks - how many rectangular masks should be cut\n    rect_freq - maximum size of cut rectangles along the frequency dimension\n    rect_time - maximum size of cut rectangles along the time dimension\n    \"\"\"\n    def __init__(\n        self,\n        rect_masks=0,\n        rect_time=5,\n        rect_freq=20,\n        rng=none\n    ):\n        super(speccutout, self).__init__()\n\n        self._rng = random.random() if rng is none else rng\n\n        self.rect_masks = rect_masks\n        self.rect_time = rect_time\n        self.rect_freq = rect_freq\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.rect_masks):\n                rect_x = int(self._rng.uniform(\n                    0, sh[1] - self.rect_freq))\n                rect_y = int(self._rng.uniform(\n                    0, sh[2] - self.rect_time))\n\n                w_x = int(self._rng.uniform(0, self.rect_time))\n                w_y = int(self._rng.uniform(0, self.rect_freq))\n\n                mask[idx, rect_x:rect_x + w_x,\n                     rect_y:rect_y + w_y] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x"], "mock", "0", "/home/blue/Documents/api-representation-learning/commons", " ", "resnet18", "a2c_ppo_acktr", -1]}, "extend": {"parameters": [false, [0, 0, 0, 0, 0], "# Adapted from https://github.com/NVIDIA/NeMo/blob/r0.9/collections/nemo_asr/\n# Copyright (C) 2020 Xilinx (Giuseppe Franco)\n# Copyright (C) 2019 NVIDIA CORPORATION.\n#\n# All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport random\n\nimport torch\nimport torch.nn as nn\n\n\nclass SpecAugment(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random continuous horisontal or\n    vertical segments of the spectrogram as described in\n    SpecAugment (https://arxiv.org/abs/1904.08779).\n\n    params:\n    freq_masks - how many frequency segments should be cut\n    time_masks - how many time segments should be cut\n    freq_width - maximum number of frequencies to be cut in one segment\n    time_width - maximum number of time steps to be cut in one segment\n    \"\"\"\n    def __init__(\n        self,\n        freq_masks=0,\n        time_masks=0,\n        freq_width=10,\n        time_width=10,\n        rng=None\n    ):\n        super(SpecAugment, self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.freq_masks = freq_masks\n        self.time_masks = time_masks\n\n        self.freq_width = freq_width\n        self.time_width = time_width\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.freq_masks):\n                x_left = int(self._rng.uniform(\n                    0, sh[1] - self.freq_width))\n\n                w = int(self._rng.uniform(0, self.freq_width))\n\n                mask[idx, x_left:x_left + w, :] = 1\n\n            for i in range(self.time_masks):\n                y_left = int(self._rng.uniform(\n                    0, sh[2] - self.time_width))\n\n                w = int(self._rng.uniform(0, self.time_width))\n\n                mask[idx, :,\n                     y_left:y_left + w] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x\n\n\nclass SpecCutout(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random rectangles in the spectrogram\n    as described in (https://arxiv.org/abs/1708.04552).\n\n    params:\n    rect_masks - how many rectangular masks should be cut\n    rect_freq - maximum size of cut rectangles along the frequency dimension\n    rect_time - maximum size of cut rectangles along the time dimension\n    \"\"\"\n    def __init__(\n        self,\n        rect_masks=0,\n        rect_time=5,\n        rect_freq=20,\n        rng=None\n    ):\n        super(SpecCutout, self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.rect_masks = rect_masks\n        self.rect_time = rect_time\n        self.rect_freq = rect_freq\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.rect_masks):\n                rect_x = int(self._rng.uniform(\n                    0, sh[1] - self.rect_freq))\n                rect_y = int(self._rng.uniform(\n                    0, sh[2] - self.rect_time))\n\n                w_x = int(self._rng.uniform(0, self.rect_time))\n                w_y = int(self._rng.uniform(0, self.rect_freq))\n\n                mask[idx, rect_x:rect_x + w_x,\n                     rect_y:rect_y + w_y] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x\n", ["[MASK]", "[MASK]", "[MASK]", "[MASK]"], ["foo"], [0, 0, 0, 0], ["basic-auth-login"], "value", null, ["-c"], ["LABEL2", "LABEL2", "LABEL2", "LABEL2", "LABEL2", "LABEL2", "LABEL2", "LABEL2", "LABEL2", "LABEL2", "LABEL2", "LABEL2", "LABEL2", "LABEL2", "LABEL2", "LABEL2", "LABEL2", "LABEL2", "LABEL2", "LABEL2"], "..", [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1], ["0"]]}, "insert": {"index": [0, 1, 2, 3, -1, null, -2], "module": [0, 1, "", "blocks", 2, "/home/blue/Documents/api-representation-learning", "/home/blue/Documents/api-representation-learning/commons/../../deps/readies", [[9, 15], "[MASK]"], "/home/blue/Documents/seq2seq", "../pytorch-segmentation-detection/vision/", "<blank>", 16, "/home/blue/Documents/echotorch", "latest", "/home/blue/Documents/api-representation-learning/torchnet", "/home/blue/Documents/api-representation-learning/commons/..", "/home/blue/Documents/api-representation-learning/commons/../..", "<PAD>", "../monoloco", 30, "/home/ubuntu/dev/opencv-3.1/build/lib", "./sepconv", "/home/blue/Documents", "lib/", "../../", "[CLS]", "#", "fpath", "../slim", "/home/blue/Documents/api-representation-learning/commons/../../vedaseg", "Not Found...", "_tid_", "/data1/ravikiran/SketchObjPartSegmentation/src/caffe-switch/caffe/python", "/home/blue", "../..", "<BOS>", "../", "cocoapi/PythonAPI", "_BOS_", "The model and loaded state dict do not match exactly\n", "knn_method", "attribute", "_", "/home/blue/Documents/api-representation-learning/espnet/nets", "/home/blue/Documents/api-representation-learning/nmtpytorch", "/home/blue/Documents/api-representation-learning/commons/readies", "_pad_", "..", "tacotron2", ".", "vid", "runs", "/home/blue/Documents/cogdl", "/home/blue/python", "Epoch", "./correlation", "/home/blue/Documents/api-representation-learning/commons/transformers/src", "/home/blue/Documents/src", "/home/blue/Documents/src/sdk/pynni", "BACKGROUND", "0", "/home/blue/Documents/api-representation-learning/torchnlp", "/home/blue/Documents/api-representation-learning/commons", null, "trial", "../github_crawler/torch_pyfiles", -1]}, "clear": {}, "items": {}, "keys": {}, "pop": {"key": [0, 1, "", "has_global_stats", "initializer", "transform", "_call_agg", "text_field_embedder", "nn_baseline", "inputs", "__dict__", "skip", "buffer_sizes", "spec_params", "features_only", "models", "epoch", "parallel", "pos", "base", "_type", "extra_volumes", "indexer", "input", "validate", "with_category_rank", "repeats", "histogram", "fallback_on_stride", "_expire_time", "learning_rate", "expected_outputs", "_default_config", "encoder", "embedding_vectors", "tuple_length", "/dir", "succeeded", "masked_lm_labels", "tag", "decoder_input_ids", "command", "scale_factor", "label", "test_time_pool", "prev_output_tokens", "beam_size", "pretrained_backbone", "id", "history", "auths", "logits.weight", "model_details", "vocabulary", "uctr", "loss1", "activation", "data_buffer", "tgt_len", "columns_value", "bn_tf", "content-encoding", "dimension", "uuid", "noise", "opset_imports", "search", "block_type", "special_tokens", "num_boost_round", "proba", "_model_id", "collections", "POLYAXON_BROKER_BACKEND", "layers", "classifier.bias", "device", "_modify", "module", "add_batch_rank", "pyver", "groups", "Unknown", "MALLOC_ARENA_MAX", "iterators", "paramwise_options", "seed", "added_tokens_file", "tokens", "state", "object_type", "DMLC_ROLE", "includes", "q_error_msg", "losses", "graph_fn_num_outputs", "run_single_eval", "seek_end", "img", "there", "resample", "image_dim", "income_bracket", "options_file", "modules", "arch", "split_ratio", "request_size", "task_id", "__input_type__", "filter", "save_path", "choices", "fc.weight", "with_align", "b", "apex", "build_ext", "deepStr", "ref", "obs", "use_bias", "ray_spec", "raw_action", "DNet_cfg", "optimization", "batch_size", "figsize", "text_processor", "dsz", "all_val", "config", "_key2class", "8de2f53e64cb", "selection", "model", "normalize_weights", "AWS_ACCESS_KEY_ID", "imgs", "scope", "_reverse", "session", "time_compilation", "src_embeddings", "train_init", "_fc.bias", "api_token", "sess_config", "kwargs", "preprocessing_spec", "param1", "optimizer", "shape", "dataset_reader", "advertise_addr", "corpus_id", "ignore_index", "cache_dir", "-h", "transformers_config", "roidb", "upsample_kernel", "get_model_args", "cchunk", "need_align", "nodeLabels", "finetuning_task", "experiment_name", "class_agnostic", "datasets_for_vocab_creation", "lm_labels", "patch_stdout", "13", "offsets", "_startinline", "covar_cache", "pca_path", "sz_batch", "num_worker_environments", "model_type", "name", "format", "use_all", "input_mask", "dataset", "spill_volumes", "metric_tracker", "requires_grad", "Content", "self", "input_size", "output_hidden_states", "im_info", "classifier.weight", "hidden_sizes", "update_rule", "C", "dense.weight", "_delay", "error_msg", "classifier.1.bias", "local", "scale", "depthwise", "weight_decay", "strict", "evals_result", "stdout", "default", "bbox", "num_classes", "model_root", "feature_np", "multiplier_transorm", "fn_cache", "model_params", "created_at", "log_when_fail", "answers", "y", "params", "data_time", "evaluation_metrics", "src_mask", "retry_timedelta", "merge_tuples_into_one", "datasets", "save_other_options", "features", "args", "test_data", "key", "_key_value", "Origin", "strict_enumeration_warning", "num_quant_bins", "_parent", "distributed", "data_path", "x", "specials", "last_transition_time", "n_batch_placeholder", "bar", "email", "n", "out", "gnes_config", "norm_layer", "from", "init", "len_train", "ctx", "syft", "kernel_size", "anno_info", "bigdl_type", "file_type", "purge_step", "vocab", "pos_bboxes", "w_std", "backend", "h", "options", "multilabel", "with_zero", "timeout", "survived", "TYPE", "hash_keys", "torch", "p", "max_retries", "num_records", "sess", "loss", "Species", "preprocessor_spec", "_count_always_valid", "CUDA_VISIBLE_DEVICES", "root_name", "logdir", "__object__", "cb_state", "embed_type", "files", "image", "seq_first", "weight", "_fc.weight", "mixed_prec", "cache_path", "level", "_pyro_model_id", "last_linear.bias", "escape", "caffe_proto", "chunk_size", "address", "fc.bias", "spec", "padding", "username", "custom_arg", "beam_runner", "shuffle", "token_length", null, "height", "foo", "src", "resume", "order", "alpha", "marks", "async_sleep_interval", "_use_inf_as_na", "flatten_ops", "api_methods", "axes", "indexing", "max_len", "1to3", "transforms", "state_dict", "num_samples", "attn_layers", "validation_dataset_reader", "n_time_step", "callbacks", "from_layer", "dtype", "tgt", "normalize_output", "step", "epochs", "use_tokens", "c8", "image_id", "loss_person_cls", "values", "masked_lm_loss", "root_workdir", "meters", "choice", "tchebycheff", "cls_prob", "identity", "op", "executable_dag", "num_parallel", "__box_heritage", "project_name", "type", -1, "component", "num_steps", "force", "as_sequential"]}, "ctc_loss": {"log_probs": [null], "targets": [null], "input_lengths": [null], "target_lengths": [null], "blank": [null], "reduction": ["sum"], "zero_infinity": [true]}, "hinge_embedding_loss": {"input": [null], "target": [null], "margin": [null], "size_average": [null], "reduce": [], "reduction": []}, "kl_div": {"input": [0, null], "target": [null], "size_average": [false, null], "reduce": [false, null], "reduction": ["batchmean", "sum", "none"]}, "update": {"parameters": [0, 1, [1, 2], "Le", 100, "tree", [["0"]], ["#", "Adapted", "from", "https://github.com/NVIDIA/NeMo/blob/r0.9/collections/nemo_asr/\n#", "Copyright", "(C)", "2020", "Xilinx", "(Giuseppe", "Franco)\n#", "Copyright", "(C)", "2019", "NVIDIA", "CORPORATION.\n#\n#", "All", "Rights", "Reserved.\n#\n#", "Licensed", "under", "the", "Apache", "License,", "Version", "2.0", "(the", "\"License\");\n#", "you", "may", "not", "use", "this", "file", "except", "in", "compliance", "with", "the", "License.\n#", "You", "may", "obtain", "a", "copy", "of", "the", "License", "at\n#\n#", "", "", "", "", "", "http://www.apache.org/licenses/LICENSE-2.0\n#\n#", "Unless", "required", "by", "applicable", "law", "or", "agreed", "to", "in", "writing,", "software\n#", "distributed", "under", "the", "License", "is", "distributed", "on", "an", "\"AS", "IS\"", "BASIS,\n#", "WITHOUT", "WARRANTIES", "OR", "CONDITIONS", "OF", "ANY", "KIND,", "either", "express", "or", "implied.\n#", "See", "the", "License", "for", "the", "specific", "language", "governing", "permissions", "and\n#", "limitations", "under", "the", "License.\n\nimport", "random\n\nimport", "torch\nimport", "torch.nn", "as", "nn\n\n\nclass", "SpecAugment(nn.Module):\n", "", "", "", "\"\"\"\n", "", "", "", "Zeroes", "out(cuts)", "random", "continuous", "horisontal", "or\n", "", "", "", "vertical", "segments", "of", "the", "spectrogram", "as", "described", "in\n", "", "", "", "SpecAugment", "(https://arxiv.org/abs/1904.08779).\n\n", "", "", "", "params:\n", "", "", "", "freq_masks", "-", "how", "many", "frequency", "segments", "should", "be", "cut\n", "", "", "", "time_masks", "-", "how", "many", "time", "segments", "should", "be", "cut\n", "", "", "", "freq_width", "-", "maximum", "number", "of", "frequencies", "to", "be", "cut", "in", "one", "segment\n", "", "", "", "time_width", "-", "maximum", "number", "of", "time", "steps", "to", "be", "cut", "in", "one", "segment\n", "", "", "", "\"\"\"\n", "", "", "", "def", "__init__(\n", "", "", "", "", "", "", "", "self,\n", "", "", "", "", "", "", "", "freq_masks=0,\n", "", "", "", "", "", "", "", "time_masks=0,\n", "", "", "", "", "", "", "", "freq_width=10,\n", "", "", "", "", "", "", "", "time_width=10,\n", "", "", "", "", "", "", "", "rng=None\n", "", "", "", "):\n", "", "", "", "", "", "", "", "super(SpecAugment,", "self).__init__()\n\n", "", "", "", "", "", "", "", "self._rng", "=", "random.Random()", "if", "rng", "is", "None", "else", "rng\n\n", "", "", "", "", "", "", "", "self.freq_masks", "=", "freq_masks\n", "", "", "", "", "", "", "", "self.time_masks", "=", "time_masks\n\n", "", "", "", "", "", "", "", "self.freq_width", "=", "freq_width\n", "", "", "", "", "", "", "", "self.time_width", "=", "time_width\n\n", "", "", "", "@torch.no_grad()\n", "", "", "", "def", "forward(self,", "x):\n", "", "", "", "", "", "", "", "sh", "=", "x.shape\n\n", "", "", "", "", "", "", "", "mask", "=", "torch.zeros(x.shape).byte()\n\n", "", "", "", "", "", "", "", "for", "idx", "in", "range(sh[0]):\n", "", "", "", "", "", "", "", "", "", "", "", "for", "i", "in", "range(self.freq_masks):\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "x_left", "=", "int(self._rng.uniform(\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "0,", "sh[1]", "-", "self.freq_width))\n\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "w", "=", "int(self._rng.uniform(0,", "self.freq_width))\n\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "mask[idx,", "x_left:x_left", "+", "w,", ":]", "=", "1\n\n", "", "", "", "", "", "", "", "", "", "", "", "for", "i", "in", "range(self.time_masks):\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "y_left", "=", "int(self._rng.uniform(\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "0,", "sh[2]", "-", "self.time_width))\n\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "w", "=", "int(self._rng.uniform(0,", "self.time_width))\n\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "mask[idx,", ":,\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "y_left:y_left", "+", "w]", "=", "1\n\n", "", "", "", "", "", "", "", "x", "=", "x.masked_fill(mask.type(torch.bool).to(device=x.device),", "0)\n\n", "", "", "", "", "", "", "", "return", "x\n\n\nclass", "SpecCutout(nn.Module):\n", "", "", "", "\"\"\"\n", "", "", "", "Zeroes", "out(cuts)", "random", "rectangles", "in", "the", "spectrogram\n", "", "", "", "as", "described", "in", "(https://arxiv.org/abs/1708.04552).\n\n", "", "", "", "params:\n", "", "", "", "rect_masks", "-", "how", "many", "rectangular", "masks", "should", "be", "cut\n", "", "", "", "rect_freq", "-", "maximum", "size", "of", "cut", "rectangles", "along", "the", "frequency", "dimension\n", "", "", "", "rect_time", "-", "maximum", "size", "of", "cut", "rectangles", "along", "the", "time", "dimension\n", "", "", "", "\"\"\"\n", "", "", "", "def", "__init__(\n", "", "", "", "", "", "", "", "self,\n", "", "", "", "", "", "", "", "rect_masks=0,\n", "", "", "", "", "", "", "", "rect_time=5,\n", "", "", "", "", "", "", "", "rect_freq=20,\n", "", "", "", "", "", "", "", "rng=None\n", "", "", "", "):\n", "", "", "", "", "", "", "", "super(SpecCutout,", "self).__init__()\n\n", "", "", "", "", "", "", "", "self._rng", "=", "random.Random()", "if", "rng", "is", "None", "else", "rng\n\n", "", "", "", "", "", "", "", "self.rect_masks", "=", "rect_masks\n", "", "", "", "", "", "", "", "self.rect_time", "=", "rect_time\n", "", "", "", "", "", "", "", "self.rect_freq", "=", "rect_freq\n\n", "", "", "", "@torch.no_grad()\n", "", "", "", "def", "forward(self,", "x):\n", "", "", "", "", "", "", "", "sh", "=", "x.shape\n\n", "", "", "", "", "", "", "", "mask", "=", "torch.zeros(x.shape).byte()\n\n", "", "", "", "", "", "", "", "for", "idx", "in", "range(sh[0]):\n", "", "", "", "", "", "", "", "", "", "", "", "for", "i", "in", "range(self.rect_masks):\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "rect_x", "=", "int(self._rng.uniform(\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "0,", "sh[1]", "-", "self.rect_freq))\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "rect_y", "=", "int(self._rng.uniform(\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "0,", "sh[2]", "-", "self.rect_time))\n\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "w_x", "=", "int(self._rng.uniform(0,", "self.rect_time))\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "w_y", "=", "int(self._rng.uniform(0,", "self.rect_freq))\n\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "mask[idx,", "rect_x:rect_x", "+", "w_x,\n", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "rect_y:rect_y", "+", "w_y]", "=", "1\n\n", "", "", "", "", "", "", "", "x", "=", "x.masked_fill(mask.type(torch.bool).to(device=x.device),", "0)\n\n", "", "", "", "", "", "", "", "return", "x"], "data_time", "loss_train_total", "model_name", "user_basic", "data.task", null, "user_advaced", "value", "../github_crawler/torch_pyfiles", ["#", " ", "A", "d", "a", "p", "t", "e", "d", " ", "f", "r", "o", "m", " ", "h", "t", "t", "p", "s", ":", "/", "/", "g", "i", "t", "h", "u", "b", ".", "c", "o", "m", "/", "N", "V", "I", "D", "I", "A", "/", "N", "e", "M", "o", "/", "b", "l", "o", "b", "/", "r", "0", ".", "9", "/", "c", "o", "l", "l", "e", "c", "t", "i", "o", "n", "s", "/", "n", "e", "m", "o", "_", "a", "s", "r", "/", "\n", "#", " ", "C", "o", "p", "y", "r", "i", "g", "h", "t", " ", "(", "C", ")", " ", "2", "0", "2", "0", " ", "X", "i", "l", "i", "n", "x", " ", "(", "G", "i", "u", "s", "e", "p", "p", "e", " ", "F", "r", "a", "n", "c", "o", ")", "\n", "#", " ", "C", "o", "p", "y", "r", "i", "g", "h", "t", " ", "(", "C", ")", " ", "2", "0", "1", "9", " ", "N", "V", "I", "D", "I", "A", " ", "C", "O", "R", "P", "O", "R", "A", "T", "I", "O", "N", ".", "\n", "#", "\n", "#", " ", "A", "l", "l", " ", "R", "i", "g", "h", "t", "s", " ", "R", "e", "s", "e", "r", "v", "e", "d", ".", "\n", "#", "\n", "#", " ", "L", "i", "c", "e", "n", "s", "e", "d", " ", "u", "n", "d", "e", "r", " ", "t", "h", "e", " ", "A", "p", "a", "c", "h", "e", " ", "L", "i", "c", "e", "n", "s", "e", ",", " ", "V", "e", "r", "s", "i", "o", "n", " ", "2", ".", "0", " ", "(", "t", "h", "e", " ", "\"", "L", "i", "c", "e", "n", "s", "e", "\"", ")", ";", "\n", "#", " ", "y", "o", "u", " ", "m", "a", "y", " ", "n", "o", "t", " ", "u", "s", "e", " ", "t", "h", "i", "s", " ", "f", "i", "l", "e", " ", "e", "x", "c", "e", "p", "t", " ", "i", "n", " ", "c", "o", "m", "p", "l", "i", "a", "n", "c", "e", " ", "w", "i", "t", "h", " ", "t", "h", "e", " ", "L", "i", "c", "e", "n", "s", "e", ".", "\n", "#", " ", "Y", "o", "u", " ", "m", "a", "y", " ", "o", "b", "t", "a", "i", "n", " ", "a", " ", "c", "o", "p", "y", " ", "o", "f", " ", "t", "h", "e", " ", "L", "i", "c", "e", "n", "s", "e", " ", "a", "t", "\n", "#", "\n", "#", " ", " ", " ", " ", " ", " ", "h", "t", "t", "p", ":", "/", "/", "w", "w", "w", ".", "a", "p", "a", "c", "h", "e", ".", "o", "r", "g", "/", "l", "i", "c", "e", "n", "s", "e", "s", "/", "L", "I", "C", "E", "N", "S", "E", "-", "2", ".", "0", "\n", "#", "\n", "#", " ", "U", "n", "l", "e", "s", "s", " ", "r", "e", "q", "u", "i", "r", "e", "d", " ", "b", "y", " ", "a", "p", "p", "l", "i", "c", "a", "b", "l", "e", " ", "l", "a", "w", " ", "o", "r", " ", "a", "g", "r", "e", "e", "d", " ", "t", "o", " ", "i", "n", " ", "w", "r", "i", "t", "i", "n", "g", ",", " ", "s", "o", "f", "t", "w", "a", "r", "e", "\n", "#", " ", "d", "i", "s", "t", "r", "i", "b", "u", "t", "e", "d", " ", "u", "n", "d", "e", "r", " ", "t", "h", "e", " ", "L", "i", "c", "e", "n", "s", "e", " ", "i", "s", " ", "d", "i", "s", "t", "r", "i", "b", "u", "t", "e", "d", " ", "o", "n", " ", "a", "n", " ", "\"", "A", "S", " ", "I", "S", "\"", " ", "B", "A", "S", "I", "S", ",", "\n", "#", " ", "W", "I", "T", "H", "O", "U", "T", " ", "W", "A", "R", "R", "A", "N", "T", "I", "E", "S", " ", "O", "R", " ", "C", "O", "N", "D", "I", "T", "I", "O", "N", "S", " ", "O", "F", " ", "A", "N", "Y", " ", "K", "I", "N", "D", ",", " ", "e", "i", "t", "h", "e", "r", " ", "e", "x", "p", "r", "e", "s", "s", " ", "o", "r", " ", "i", "m", "p", "l", "i", "e", "d", ".", "\n", "#", " ", "S", "e", "e", " ", "t", "h", "e", " ", "L", "i", "c", "e", "n", "s", "e", " ", "f", "o", "r", " ", "t", "h", "e", " ", "s", "p", "e", "c", "i", "f", "i", "c", " ", "l", "a", "n", "g", "u", "a", "g", "e", " ", "g", "o", "v", "e", "r", "n", "i", "n", "g", " ", "p", "e", "r", "m", "i", "s", "s", "i", "o", "n", "s", " ", "a", "n", "d", "\n", "#", " ", "l", "i", "m", "i", "t", "a", "t", "i", "o", "n", "s", " ", "u", "n", "d", "e", "r", " ", "t", "h", "e", " ", "L", "i", "c", "e", "n", "s", "e", ".", "\n", "\n", "i", "m", "p", "o", "r", "t", " ", "r", "a", "n", "d", "o", "m", "\n", "\n", "i", "m", "p", "o", "r", "t", " ", "t", "o", "r", "c", "h", "\n", "i", "m", "p", "o", "r", "t", " ", "t", "o", "r", "c", "h", ".", "n", "n", " ", "a", "s", " ", "n", "n", "\n", "\n", "\n", "c", "l", "a", "s", "s", " ", "S", "p", "e", "c", "A", "u", "g", "m", "e", "n", "t", "(", "n", "n", ".", "M", "o", "d", "u", "l", "e", ")", ":", "\n", " ", " ", " ", " ", "\"", "\"", "\"", "\n", " ", " ", " ", " ", "Z", "e", "r", "o", "e", "s", " ", "o", "u", "t", "(", "c", "u", "t", "s", ")", " ", "r", "a", "n", "d", "o", "m", " ", "c", "o", "n", "t", "i", "n", "u", "o", "u", "s", " ", "h", "o", "r", "i", "s", "o", "n", "t", "a", "l", " ", "o", "r", "\n", " ", " ", " ", " ", "v", "e", "r", "t", "i", "c", "a", "l", " ", "s", "e", "g", "m", "e", "n", "t", "s", " ", "o", "f", " ", "t", "h", "e", " ", "s", "p", "e", "c", "t", "r", "o", "g", "r", "a", "m", " ", "a", "s", " ", "d", "e", "s", "c", "r", "i", "b", "e", "d", " ", "i", "n", "\n", " ", " ", " ", " ", "S", "p", "e", "c", "A", "u", "g", "m", "e", "n", "t", " ", "(", "h", "t", "t", "p", "s", ":", "/", "/", "a", "r", "x", "i", "v", ".", "o", "r", "g", "/", "a", "b", "s", "/", "1", "9", "0", "4", ".", "0", "8", "7", "7", "9", ")", ".", "\n", "\n", " ", " ", " ", " ", "p", "a", "r", "a", "m", "s", ":", "\n", " ", " ", " ", " ", "f", "r", "e", "q", "_", "m", "a", "s", "k", "s", " ", "-", " ", "h", "o", "w", " ", "m", "a", "n", "y", " ", "f", "r", "e", "q", "u", "e", "n", "c", "y", " ", "s", "e", "g", "m", "e", "n", "t", "s", " ", "s", "h", "o", "u", "l", "d", " ", "b", "e", " ", "c", "u", "t", "\n", " ", " ", " ", " ", "t", "i", "m", "e", "_", "m", "a", "s", "k", "s", " ", "-", " ", "h", "o", "w", " ", "m", "a", "n", "y", " ", "t", "i", "m", "e", " ", "s", "e", "g", "m", "e", "n", "t", "s", " ", "s", "h", "o", "u", "l", "d", " ", "b", "e", " ", "c", "u", "t", "\n", " ", " ", " ", " ", "f", "r", "e", "q", "_", "w", "i", "d", "t", "h", " ", "-", " ", "m", "a", "x", "i", "m", "u", "m", " ", "n", "u", "m", "b", "e", "r", " ", "o", "f", " ", "f", "r", "e", "q", "u", "e", "n", "c", "i", "e", "s", " ", "t", "o", " ", "b", "e", " ", "c", "u", "t", " ", "i", "n", " ", "o", "n", "e", " ", "s", "e", "g", "m", "e", "n", "t", "\n", " ", " ", " ", " ", "t", "i", "m", "e", "_", "w", "i", "d", "t", "h", " ", "-", " ", "m", "a", "x", "i", "m", "u", "m", " ", "n", "u", "m", "b", "e", "r", " ", "o", "f", " ", "t", "i", "m", "e", " ", "s", "t", "e", "p", "s", " ", "t", "o", " ", "b", "e", " ", "c", "u", "t", " ", "i", "n", " ", "o", "n", "e", " ", "s", "e", "g", "m", "e", "n", "t", "\n", " ", " ", " ", " ", "\"", "\"", "\"", "\n", " ", " ", " ", " ", "d", "e", "f", " ", "_", "_", "i", "n", "i", "t", "_", "_", "(", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "f", "r", "e", "q", "_", "m", "a", "s", "k", "s", "=", "0", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "t", "i", "m", "e", "_", "m", "a", "s", "k", "s", "=", "0", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "f", "r", "e", "q", "_", "w", "i", "d", "t", "h", "=", "1", "0", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "t", "i", "m", "e", "_", "w", "i", "d", "t", "h", "=", "1", "0", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "r", "n", "g", "=", "N", "o", "n", "e", "\n", " ", " ", " ", " ", ")", ":", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "u", "p", "e", "r", "(", "S", "p", "e", "c", "A", "u", "g", "m", "e", "n", "t", ",", " ", "s", "e", "l", "f", ")", ".", "_", "_", "i", "n", "i", "t", "_", "_", "(", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ".", "_", "r", "n", "g", " ", "=", " ", "r", "a", "n", "d", "o", "m", ".", "R", "a", "n", "d", "o", "m", "(", ")", " ", "i", "f", " ", "r", "n", "g", " ", "i", "s", " ", "N", "o", "n", "e", " ", "e", "l", "s", "e", " ", "r", "n", "g", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ".", "f", "r", "e", "q", "_", "m", "a", "s", "k", "s", " ", "=", " ", "f", "r", "e", "q", "_", "m", "a", "s", "k", "s", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ".", "t", "i", "m", "e", "_", "m", "a", "s", "k", "s", " ", "=", " ", "t", "i", "m", "e", "_", "m", "a", "s", "k", "s", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ".", "f", "r", "e", "q", "_", "w", "i", "d", "t", "h", " ", "=", " ", "f", "r", "e", "q", "_", "w", "i", "d", "t", "h", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ".", "t", "i", "m", "e", "_", "w", "i", "d", "t", "h", " ", "=", " ", "t", "i", "m", "e", "_", "w", "i", "d", "t", "h", "\n", "\n", " ", " ", " ", " ", "@", "t", "o", "r", "c", "h", ".", "n", "o", "_", "g", "r", "a", "d", "(", ")", "\n", " ", " ", " ", " ", "d", "e", "f", " ", "f", "o", "r", "w", "a", "r", "d", "(", "s", "e", "l", "f", ",", " ", "x", ")", ":", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "h", " ", "=", " ", "x", ".", "s", "h", "a", "p", "e", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "m", "a", "s", "k", " ", "=", " ", "t", "o", "r", "c", "h", ".", "z", "e", "r", "o", "s", "(", "x", ".", "s", "h", "a", "p", "e", ")", ".", "b", "y", "t", "e", "(", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "f", "o", "r", " ", "i", "d", "x", " ", "i", "n", " ", "r", "a", "n", "g", "e", "(", "s", "h", "[", "0", "]", ")", ":", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "f", "o", "r", " ", "i", " ", "i", "n", " ", "r", "a", "n", "g", "e", "(", "s", "e", "l", "f", ".", "f", "r", "e", "q", "_", "m", "a", "s", "k", "s", ")", ":", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "x", "_", "l", "e", "f", "t", " ", "=", " ", "i", "n", "t", "(", "s", "e", "l", "f", ".", "_", "r", "n", "g", ".", "u", "n", "i", "f", "o", "r", "m", "(", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "0", ",", " ", "s", "h", "[", "1", "]", " ", "-", " ", "s", "e", "l", "f", ".", "f", "r", "e", "q", "_", "w", "i", "d", "t", "h", ")", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "w", " ", "=", " ", "i", "n", "t", "(", "s", "e", "l", "f", ".", "_", "r", "n", "g", ".", "u", "n", "i", "f", "o", "r", "m", "(", "0", ",", " ", "s", "e", "l", "f", ".", "f", "r", "e", "q", "_", "w", "i", "d", "t", "h", ")", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "m", "a", "s", "k", "[", "i", "d", "x", ",", " ", "x", "_", "l", "e", "f", "t", ":", "x", "_", "l", "e", "f", "t", " ", "+", " ", "w", ",", " ", ":", "]", " ", "=", " ", "1", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "f", "o", "r", " ", "i", " ", "i", "n", " ", "r", "a", "n", "g", "e", "(", "s", "e", "l", "f", ".", "t", "i", "m", "e", "_", "m", "a", "s", "k", "s", ")", ":", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "y", "_", "l", "e", "f", "t", " ", "=", " ", "i", "n", "t", "(", "s", "e", "l", "f", ".", "_", "r", "n", "g", ".", "u", "n", "i", "f", "o", "r", "m", "(", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "0", ",", " ", "s", "h", "[", "2", "]", " ", "-", " ", "s", "e", "l", "f", ".", "t", "i", "m", "e", "_", "w", "i", "d", "t", "h", ")", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "w", " ", "=", " ", "i", "n", "t", "(", "s", "e", "l", "f", ".", "_", "r", "n", "g", ".", "u", "n", "i", "f", "o", "r", "m", "(", "0", ",", " ", "s", "e", "l", "f", ".", "t", "i", "m", "e", "_", "w", "i", "d", "t", "h", ")", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "m", "a", "s", "k", "[", "i", "d", "x", ",", " ", ":", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "y", "_", "l", "e", "f", "t", ":", "y", "_", "l", "e", "f", "t", " ", "+", " ", "w", "]", " ", "=", " ", "1", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "x", " ", "=", " ", "x", ".", "m", "a", "s", "k", "e", "d", "_", "f", "i", "l", "l", "(", "m", "a", "s", "k", ".", "t", "y", "p", "e", "(", "t", "o", "r", "c", "h", ".", "b", "o", "o", "l", ")", ".", "t", "o", "(", "d", "e", "v", "i", "c", "e", "=", "x", ".", "d", "e", "v", "i", "c", "e", ")", ",", " ", "0", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "r", "e", "t", "u", "r", "n", " ", "x", "\n", "\n", "\n", "c", "l", "a", "s", "s", " ", "S", "p", "e", "c", "C", "u", "t", "o", "u", "t", "(", "n", "n", ".", "M", "o", "d", "u", "l", "e", ")", ":", "\n", " ", " ", " ", " ", "\"", "\"", "\"", "\n", " ", " ", " ", " ", "Z", "e", "r", "o", "e", "s", " ", "o", "u", "t", "(", "c", "u", "t", "s", ")", " ", "r", "a", "n", "d", "o", "m", " ", "r", "e", "c", "t", "a", "n", "g", "l", "e", "s", " ", "i", "n", " ", "t", "h", "e", " ", "s", "p", "e", "c", "t", "r", "o", "g", "r", "a", "m", "\n", " ", " ", " ", " ", "a", "s", " ", "d", "e", "s", "c", "r", "i", "b", "e", "d", " ", "i", "n", " ", "(", "h", "t", "t", "p", "s", ":", "/", "/", "a", "r", "x", "i", "v", ".", "o", "r", "g", "/", "a", "b", "s", "/", "1", "7", "0", "8", ".", "0", "4", "5", "5", "2", ")", ".", "\n", "\n", " ", " ", " ", " ", "p", "a", "r", "a", "m", "s", ":", "\n", " ", " ", " ", " ", "r", "e", "c", "t", "_", "m", "a", "s", "k", "s", " ", "-", " ", "h", "o", "w", " ", "m", "a", "n", "y", " ", "r", "e", "c", "t", "a", "n", "g", "u", "l", "a", "r", " ", "m", "a", "s", "k", "s", " ", "s", "h", "o", "u", "l", "d", " ", "b", "e", " ", "c", "u", "t", "\n", " ", " ", " ", " ", "r", "e", "c", "t", "_", "f", "r", "e", "q", " ", "-", " ", "m", "a", "x", "i", "m", "u", "m", " ", "s", "i", "z", "e", " ", "o", "f", " ", "c", "u", "t", " ", "r", "e", "c", "t", "a", "n", "g", "l", "e", "s", " ", "a", "l", "o", "n", "g", " ", "t", "h", "e", " ", "f", "r", "e", "q", "u", "e", "n", "c", "y", " ", "d", "i", "m", "e", "n", "s", "i", "o", "n", "\n", " ", " ", " ", " ", "r", "e", "c", "t", "_", "t", "i", "m", "e", " ", "-", " ", "m", "a", "x", "i", "m", "u", "m", " ", "s", "i", "z", "e", " ", "o", "f", " ", "c", "u", "t", " ", "r", "e", "c", "t", "a", "n", "g", "l", "e", "s", " ", "a", "l", "o", "n", "g", " ", "t", "h", "e", " ", "t", "i", "m", "e", " ", "d", "i", "m", "e", "n", "s", "i", "o", "n", "\n", " ", " ", " ", " ", "\"", "\"", "\"", "\n", " ", " ", " ", " ", "d", "e", "f", " ", "_", "_", "i", "n", "i", "t", "_", "_", "(", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "r", "e", "c", "t", "_", "m", "a", "s", "k", "s", "=", "0", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "r", "e", "c", "t", "_", "t", "i", "m", "e", "=", "5", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "r", "e", "c", "t", "_", "f", "r", "e", "q", "=", "2", "0", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "r", "n", "g", "=", "N", "o", "n", "e", "\n", " ", " ", " ", " ", ")", ":", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "u", "p", "e", "r", "(", "S", "p", "e", "c", "C", "u", "t", "o", "u", "t", ",", " ", "s", "e", "l", "f", ")", ".", "_", "_", "i", "n", "i", "t", "_", "_", "(", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ".", "_", "r", "n", "g", " ", "=", " ", "r", "a", "n", "d", "o", "m", ".", "R", "a", "n", "d", "o", "m", "(", ")", " ", "i", "f", " ", "r", "n", "g", " ", "i", "s", " ", "N", "o", "n", "e", " ", "e", "l", "s", "e", " ", "r", "n", "g", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ".", "r", "e", "c", "t", "_", "m", "a", "s", "k", "s", " ", "=", " ", "r", "e", "c", "t", "_", "m", "a", "s", "k", "s", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ".", "r", "e", "c", "t", "_", "t", "i", "m", "e", " ", "=", " ", "r", "e", "c", "t", "_", "t", "i", "m", "e", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "e", "l", "f", ".", "r", "e", "c", "t", "_", "f", "r", "e", "q", " ", "=", " ", "r", "e", "c", "t", "_", "f", "r", "e", "q", "\n", "\n", " ", " ", " ", " ", "@", "t", "o", "r", "c", "h", ".", "n", "o", "_", "g", "r", "a", "d", "(", ")", "\n", " ", " ", " ", " ", "d", "e", "f", " ", "f", "o", "r", "w", "a", "r", "d", "(", "s", "e", "l", "f", ",", " ", "x", ")", ":", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "s", "h", " ", "=", " ", "x", ".", "s", "h", "a", "p", "e", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "m", "a", "s", "k", " ", "=", " ", "t", "o", "r", "c", "h", ".", "z", "e", "r", "o", "s", "(", "x", ".", "s", "h", "a", "p", "e", ")", ".", "b", "y", "t", "e", "(", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "f", "o", "r", " ", "i", "d", "x", " ", "i", "n", " ", "r", "a", "n", "g", "e", "(", "s", "h", "[", "0", "]", ")", ":", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "f", "o", "r", " ", "i", " ", "i", "n", " ", "r", "a", "n", "g", "e", "(", "s", "e", "l", "f", ".", "r", "e", "c", "t", "_", "m", "a", "s", "k", "s", ")", ":", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "r", "e", "c", "t", "_", "x", " ", "=", " ", "i", "n", "t", "(", "s", "e", "l", "f", ".", "_", "r", "n", "g", ".", "u", "n", "i", "f", "o", "r", "m", "(", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "0", ",", " ", "s", "h", "[", "1", "]", " ", "-", " ", "s", "e", "l", "f", ".", "r", "e", "c", "t", "_", "f", "r", "e", "q", ")", ")", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "r", "e", "c", "t", "_", "y", " ", "=", " ", "i", "n", "t", "(", "s", "e", "l", "f", ".", "_", "r", "n", "g", ".", "u", "n", "i", "f", "o", "r", "m", "(", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "0", ",", " ", "s", "h", "[", "2", "]", " ", "-", " ", "s", "e", "l", "f", ".", "r", "e", "c", "t", "_", "t", "i", "m", "e", ")", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "w", "_", "x", " ", "=", " ", "i", "n", "t", "(", "s", "e", "l", "f", ".", "_", "r", "n", "g", ".", "u", "n", "i", "f", "o", "r", "m", "(", "0", ",", " ", "s", "e", "l", "f", ".", "r", "e", "c", "t", "_", "t", "i", "m", "e", ")", ")", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "w", "_", "y", " ", "=", " ", "i", "n", "t", "(", "s", "e", "l", "f", ".", "_", "r", "n", "g", ".", "u", "n", "i", "f", "o", "r", "m", "(", "0", ",", " ", "s", "e", "l", "f", ".", "r", "e", "c", "t", "_", "f", "r", "e", "q", ")", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "m", "a", "s", "k", "[", "i", "d", "x", ",", " ", "r", "e", "c", "t", "_", "x", ":", "r", "e", "c", "t", "_", "x", " ", "+", " ", "w", "_", "x", ",", "\n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "r", "e", "c", "t", "_", "y", ":", "r", "e", "c", "t", "_", "y", " ", "+", " ", "w", "_", "y", "]", " ", "=", " ", "1", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "x", " ", "=", " ", "x", ".", "m", "a", "s", "k", "e", "d", "_", "f", "i", "l", "l", "(", "m", "a", "s", "k", ".", "t", "y", "p", "e", "(", "t", "o", "r", "c", "h", ".", "b", "o", "o", "l", ")", ".", "t", "o", "(", "d", "e", "v", "i", "c", "e", "=", "x", ".", "d", "e", "v", "i", "c", "e", ")", ",", " ", "0", ")", "\n", "\n", " ", " ", " ", " ", " ", " ", " ", " ", "r", "e", "t", "u", "r", "n", " ", "x", "\n"]]}, "values": {}, "l1_loss": {"input": [0, "value", null], "target": [0, null], "size_average": [false, true, null], "reduce": [false, null], "reduction": [-0.5, "mean", "sum", "none", null]}, "mse_loss": {"input": [0, null], "target": [0, null], "size_average": [false, null], "reduce": [0, null], "reduction": ["mean", "sum", "none", null]}, "margin_ranking_loss": {"input1": [null], "input2": [null], "target": [null], "margin": [null], "size_average": [null], "reduce": [], "reduction": ["none", null]}, "multilabel_margin_loss": {"input": [null], "target": [null], "size_average": [], "reduce": [], "reduction": []}, "multilabel_soft_margin_loss": {"input": [null], "target": [null], "weight": [], "size_average": []}, "multi_margin_loss": {"input": [null], "target": [null], "p": [], "margin": [], "weight": [], "size_average": [], "reduce": [], "reduction": []}, "nll_loss": {"input": [0, null], "target": [null], "weight": [0, null], "size_average": [false, null], "ignore_index": [0, 250, -1, null], "reduce": [0, true, null], "reduction": ["mean", "none", "sum", null]}, "log_prob": {"input": ["value", null]}, "predict": {"input": [0, true, "record.wav", "validate", null, "mnli", "test.wav", "\u53e6\u4e00\u4e2a\u5f88\u9177\u7684\u4e8b\u60c5\u662f\uff0c\u901a\u8fc7\u6846\u67b6\u6211\u4eec\u53ef\u4ee5\u505c\u6b62\u5e76\u5728\u7a0d\u540e\u6062\u590d\u8bad\u7ec3\u3002", "\u94b1\u949f\u4e66", "\u82b1\u5457\u6536\u6b3e\u6536\u4e0d\u4e86\u600e\u4e48\u529e", "\u5411\u5168\u56fd\u5404\u65cf\u4eba\u6c11\u81f4\u4ee5\u8bda\u631a\u7684\u95ee\u5019\uff01", "\u6297\u65e5\u6218\u4e89\u65f6\u671f\uff0c\u80e1\u8001\u5728\u4e0e\u4fb5\u534e\u65e5\u519b\u4ea4\u6218\u4e2d\u56db\u6b21\u8d1f\u4f24\uff0c\u662f\u4e00\u4f4d\u4e0d\u6298\u4e0d\u6263\u7684\u6297\u6218\u8001\u82f1\u96c4", "\u5916\u89c2\u6f02\u4eae\uff0c\u5b89\u5168\u6027\u4f73\uff0c\u52a8\u529b\u591f\u5f3a\uff0c\u6cb9\u8017\u591f\u4f4e\u3002", "\u4e00\u4e2a\u5c0f\u7537\u5b69\u5728\u79cb\u5343\u4e0a\u73a9\u3002", "Hello!"]}, "convert_sync_batchnorm": {}, "flatten_parameters": {}, "smooth_l1_loss": {"input": [0, "value", null], "target": [null], "size_average": [false, true, null], "reduce": [false, null], "reduction": ["mean", "none", "sum", null]}, "soft_margin_loss": {"input": [null], "target": [null], "size_average": [], "reduce": [], "reduction": []}, "triplet_margin_loss": {"anchor": [null], "positive": [null], "negative": [null], "margin": [null], "p": [], "eps": [], "swap": [null], "size_average": [], "reduce": [], "reduction": []}, "pixel_shuffle": {}, "pad": {"input": [0, 2, 4, "# Adapted from https://github.com/NVIDIA/NeMo/blob/r0.9/collections/nemo_asr/\n# Copyright (C) 2020 Xilinx (Giuseppe Franco)\n# Copyright (C) 2019 NVIDIA CORPORATION.\n#\n# All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport random\n\nimport torch\nimport torch.nn as nn\n\n\nclass SpecAugment(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random continuous horisontal or\n    vertical segments of the spectrogram as described in\n    SpecAugment (https://arxiv.org/abs/1904.08779).\n\n    params:\n    freq_masks - how many frequency segments should be cut\n    time_masks - how many time segments should be cut\n    freq_width - maximum number of frequencies to be cut in one segment\n    time_width - maximum number of time steps to be cut in one segment\n    \"\"\"\n    def __init__(\n        self,\n        freq_masks=0,\n        time_masks=0,\n        freq_width=10,\n        time_width=10,\n        rng=None\n    ):\n        super(SpecAugment, self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.freq_masks = freq_masks\n        self.time_masks = time_masks\n\n        self.freq_width = freq_width\n        self.time_width = time_width\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.freq_masks):\n                x_left = int(self._rng.uniform(\n                    0, sh[1] - self.freq_width))\n\n                w = int(self._rng.uniform(0, self.freq_width))\n\n                mask[idx, x_left:x_left + w, :] = 1\n\n            for i in range(self.time_masks):\n                y_left = int(self._rng.uniform(\n                    0, sh[2] - self.time_width))\n\n                w = int(self._rng.uniform(0, self.time_width))\n\n                mask[idx, :,\n                     y_left:y_left + w] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x\n\n\nclass SpecCutout(nn.Module):\n    \"\"\"\n    Zeroes out(cuts) random rectangles in the spectrogram\n    as described in (https://arxiv.org/abs/1708.04552).\n\n    params:\n    rect_masks - how many rectangular masks should be cut\n    rect_freq - maximum size of cut rectangles along the frequency dimension\n    rect_time - maximum size of cut rectangles along the time dimension\n    \"\"\"\n    def __init__(\n        self,\n        rect_masks=0,\n        rect_time=5,\n        rect_freq=20,\n        rng=None\n    ):\n        super(SpecCutout, self).__init__()\n\n        self._rng = random.Random() if rng is None else rng\n\n        self.rect_masks = rect_masks\n        self.rect_time = rect_time\n        self.rect_freq = rect_freq\n\n    @torch.no_grad()\n    def forward(self, x):\n        sh = x.shape\n\n        mask = torch.zeros(x.shape).byte()\n\n        for idx in range(sh[0]):\n            for i in range(self.rect_masks):\n                rect_x = int(self._rng.uniform(\n                    0, sh[1] - self.rect_freq))\n                rect_y = int(self._rng.uniform(\n                    0, sh[2] - self.rect_time))\n\n                w_x = int(self._rng.uniform(0, self.rect_time))\n                w_y = int(self._rng.uniform(0, self.rect_freq))\n\n                mask[idx, rect_x:rect_x + w_x,\n                     rect_y:rect_y + w_y] = 1\n\n        x = x.masked_fill(mask.type(torch.bool).to(device=x.device), 0)\n\n        return x\n", "value", null], "pad": [[[0, 280], [0, 280], [0, 0]], 0.0, 2, [[0, 1], [0, 1]], 1, [[20, 20], [20, 20]], 3, [[1000, 1000], [1000, 1000], [0, 0]], [1, 1, 1, 1], 14, [0, 0, 1, 1], [[0, 0], [1, 1]], 28, [3, 3, 3, 3], 32, [[0, 0], [0, 0], [16, 16]], [[1, 1], [1, 1]], [2, 2, 2, 2], 40, [[0, 128], [0, 400], [0, 0]], [14, 14], [[0, 1], [0, 0]], [[0, 0], [1, 1], [1, 1]], [0, 1, 0, 1], [4, 5], [1, 0, 1, 0], [0, 1, 0, 0], [2, 4, 2, 4, 2, 4], [1, 0], [0, 1], [[0, 0], [28, 28], [28, 28]], [-1, 1, -1, 1], [1, 1, 0, 0], [0, 0, 0, 0, 1, 0], [[0, 0], [0, 4], [0, 0]], [0, 0, 1, 0], [[30, 0], [0, 300], [0, 0]], [16, 16, 16, 16], [[1, 0], [0, 0], [0, 0]], null, "../github_crawler/torch_pyfiles"], "mode": [0, "circular", 1, "reflect", 4, 5, [0, 0], [1, 0, 0, 0], 40, "constant", "CONSTANT", "wrap", "replicate", 16, "edge", null, [[0, 0], [1, 0]], "REFLECT"], "value": [0, 1, 0.447, 5, [2, 2], "constant", [0, 0, 1, 0], "edge", 16, "value", null, [1, 0], -1]}, "generate_square_subsequent_mask": {"sz": [null]}, "from_pretrained": {"embeddings": [0, "efficientnet-b0", "camembert-base", "username/pretrained_model", "cl-tohoku/bert-base-japanese", "albert-base-v1", "jplu/tf-flaubert-small-cased", "roberta-base", "bert-base-cased", "gpt2", "Helsinki-NLP/opus-mt-en-de", "efficientnet-b3", "distilbert-base-uncased", "xxx-base-uncased", "flaubert-base-cased", "openai-gpt", "allenai/longformer-base-4096", "bert-large-uncased-whole-word-masking-finetuned-squad", "efficientnet-b1", "deepset/bert-base-cased-squad2", "facebook/bart-large", "xlm-roberta-base", "albert-base-v2", "bart-large-cnn", "google/electra-small-discriminator", "google/reformer-crime-and-punishment", "jplu/tf-xlm-roberta-base", "bart-large", "albert-base-uncased", "mmbt.hateful_memes.images", "transfo-xl-wt103", null, "dbmdz/bert-large-cased-finetuned-conll03-english", "bert-base-chinese", "xlnet-base-cased", "t5-small", "ctrl", "distilbert-base-cased", "xlnet-large-cased", "xlm-mlm-en-2048", "jplu/tf-camembert-base", "bert-base-uncased"], "freeze": [0, true, null], "max_norm": [null], "norm_type": [null], "scale_grad_by_freq": [null], "mode": [null], "sparse": [null], "include_last_offset": [null]}, "grid_sample": {"input": [0, "value", null], "grid": [null], "mode": ["bilinear", null], "padding_mode": ["border", "zeros", null], "align_corners": [false, true, null]}, "no_sync": {}, "apply_mask": {}, "compute_mask": {}, "prune": {}, "add_pruning_method": {}, "affine_grid": {"theta": [null], "size": [null], "align_corners": [false, null]}, "data_parallel": {"module": [null], "inputs": [0, [], null], "device_ids": [0, null], "output_device": [0, 1, null], "dim": [0, 2, null], "module_kwargs": [0, null]}, "Parameter": {}, "Module": {}, "dump_patches": {}, "Sequential": {"*args": [0, null]}, "ModuleList": {"modules": [[], null]}, "ModuleDict": {"modules": [null]}, "ParameterList": {"parameters": [null]}, "ParameterDict": {"parameters": [null]}, "Conv1d": {"in_channels": [128, 161, 1, 64, 1024, 1088, 6, 4, 2, 5, 10, 16, null], "out_channels": [128, 512, 32, 64, 1024, 1, 256, 5, 3, 10, 16, 500, null], "kernel_size": [1, 2, 3, 5, 7, 10, 15, 48, null], "stride": [1, 2, null], "padding": [0, 97, 2, 1, "same", null], "dilation": [1, 27, null], "groups": [64, 1, null], "bias": [false, true, null], "padding_mode": ["circular", "zeros"]}, "ConvTranspose1d": {"in_channels": [512, 1, null], "out_channels": [256, 1, null], "kernel_size": [16, 1024, 2, null], "stride": [8, 256, 2, null], "padding": [0, "same", 4, null], "output_padding": [null], "groups": [null], "bias": [false, null], "dilation": [null], "padding_mode": []}, "ConvTranspose2d": {"in_channels": [512, 128, 256, 1, 2, 1024, 2048, 3, 8, 1280, 16, 32, 168, 48, 64, 74, 96, 100, 228, null], "out_channels": [256, 64, 128, 32, 1, 2, 4, 3, 512, 96, 8, 1024, 448, 16, 48, null], "kernel_size": [64, 1, 2, 3, 4, 5, [3, 3], 8, [2, 2], 9, [4, 4], 15, 16, null], "stride": [32, 1, 2, 8, [2, 2], 15, null], "padding": [0, 1, 2, 3, 4, null, [1, 1]], "output_padding": [0, 1, [1, 1], null], "groups": [1, 2, null], "bias": [false, true, null], "dilation": [1, null], "padding_mode": []}, "ConvTranspose3d": {"in_channels": [64, 256, 32, 200, null], "out_channels": [64, 256, 512, 16, null], "kernel_size": [2, 3, 4, [4, 4, 4], null], "stride": [[2, 2, 2], 2, null], "padding": [0, 1, [1, 1, 1], null], "output_padding": [1, null], "groups": [null], "bias": [false, null], "dilation": [], "padding_mode": []}, "Unfold": {"kernel_size": [0], "dilation": [], "padding": [], "stride": []}, "Fold": {"output_size": [0, 5, null, "Conv > BatchNormalization > Relu", "a > b", "Conv > BiasAdd"], "kernel_size": ["ConvBnRelu", "__first__", "ab"], "dilation": [], "padding": [], "stride": []}, "MaxPool1d": {"kernel_size": [1, 2, 3, null], "stride": [1, 2, 3, null], "padding": [0, 1, null], "dilation": [1], "return_indices": [false], "ceil_mode": [false, true]}, "MaxPool2d": {"kernel_size": [1, 2, 3, [3, 2], [3, 3], 5, 4, [2, 2], [4, 4], [56, 56], [8, 8], null, [1, 1]], "stride": [0, 1, 2, [1, 2], 4, null, [56, 56], [2, 2]], "padding": [0, 1, 2, [0, 0], "SAME", null, [1, 1]], "dilation": [1, [1, 1], null], "return_indices": [false, true], "ceil_mode": [false, true, null]}, "MaxPool3d": {"kernel_size": [[3, 3, 3], [2, 2, 2], 2, 3, [1, 2, 2], null, [1, 3, 3]], "stride": [1, 2, 3, [1, 2, 2], null, [1, 1, 1]], "padding": [0, 1, null], "dilation": [[1, 1, 1]], "return_indices": [false, 2], "ceil_mode": [true, null]}, "MaxUnpool1d": {"kernel_size": [2], "stride": [2], "padding": []}, "MaxUnpool2d": {"kernel_size": [2, 3], "stride": [2], "padding": [0]}, "MaxUnpool3d": {"kernel_size": [], "stride": [], "padding": []}, "AvgPool1d": {"kernel_size": [1, 3, 4, null], "stride": [1, 2, null], "padding": [0, 1, null], "ceil_mode": [], "count_include_pad": [false]}, "AvgPool2d": {"kernel_size": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, [32, 32], [7, 7], 13, 14, 28, [3, 3], [4, 4], [14, 14], 56, [2, 2], [1, 1], [64, 64], null, [8, 4]], "stride": [1, 2, 3, [64, 64], 5, 6, 7, [32, 32], [2, 2], [4, 4], [7, 7], null, [1, 1]], "padding": [0, 1, 2, [0, 0], null], "ceil_mode": [false, true, null], "count_include_pad": [false, true, null], "divisor_override": []}, "AvgPool3d": {"kernel_size": [1, 2, [1, 4, 4], [2, 7, 7], [2, 3, 3], [5, 1, 1], null, [1, 1, 1]], "stride": [[1, 1, 1], 1, 2, 7], "padding": [[0, 1, 1], null], "ceil_mode": [], "count_include_pad": []}, "FractionalMaxPool2d": {"kernel_size": [2], "output_size": [], "output_ratio": [null], "return_indices": []}, "LPPool1d": {"norm_type": [], "kernel_size": [], "stride": [], "ceil_mode": []}, "LPPool2d": {"norm_type": [2], "kernel_size": [[3, 3]], "stride": [[3, 3]], "ceil_mode": []}, "AdaptiveMaxPool1d": {"output_size": [1, null], "return_indices": []}, "AdaptiveMaxPool2d": {"output_size": [1, [1, 0], [1, 1], null], "return_indices": []}, "AdaptiveMaxPool3d": {"output_size": [1, null], "return_indices": []}, "AdaptiveAvgPool1d": {"output_size": [1, null]}, "AdaptiveAvgPool2d": {"output_size": [1, 2, 3, [14, 14], [3, 3], 4, [7, 7], null, [1, 1]]}, "AdaptiveAvgPool3d": {"output_size": [1, [1, 1, 1], null]}, "ReflectionPad1d": {"padding": [1, 3, 7, null]}, "ReflectionPad2d": {"padding": [0, 1, 3, [40, 40, 40, 40], [1, 1, 1, 1], null]}, "ReplicationPad1d": {"padding": [null]}, "ReplicationPad2d": {"padding": [[1, 0, 1, 0], 1, [1, 1, 0, 0], null]}, "ReplicationPad3d": {"padding": [[0, 0, 0, 0, 1, 1], null]}, "ZeroPad2d": {"padding": [1, [3, 3, 0, 0], [1, 0, 0, 0], [1, 0, 1, 0], null, [1, 1, 1, 1], [0, 1, 0, 1]]}, "ConstantPad1d": {"padding": [[0, 1], [0, 0], null], "value": [0, 1, null]}, "ConstantPad2d": {"padding": [1, [0, 1, 0, 1], null], "value": [0, 0.5, 1, null, -1, 255]}, "ConstantPad3d": {"padding": [null], "value": [0]}, "ELU": {"alpha": [0.075, true, 0.5, null], "inplace": [false, true, null]}, "Hardshrink": {"lambd": []}, "Hardtanh": {"min_val": [0.0, 1, null], "max_val": [1.0, 2, null], "inplace": [true], "min_value": [], "max_value": []}, "LeakyReLU": {"negative_slope": [0.2, 0.1, 0.05, 0.4, true, 0.01, null, 0.02], "inplace": [false, true, null]}, "LogSigmoid": {}, "MultiheadAttention": {}, "PReLU": {"num_parameters": [256, 64, 35, 3, 10, 13, 16, null], "init": [32, 0, 128, 0.25, null]}, "RReLU": {"lower": [0.123, 0.25, null], "upper": [0.456], "inplace": [true]}, "SELU": {"inplace": [true, null]}, "CELU": {"alpha": [0.075, null], "inplace": [false]}, "GELU": {}, "Sigmoid": {}, "Softplus": {"beta": [1, null], "threshold": [20, null]}, "Softshrink": {"lambd": []}, "Softsign": {}, "Tanh": {}, "Tanhshrink": {}, "Threshold": {"threshold": [0, null], "value": [0, 1e-06, null], "inplace": [null]}, "Softmin": {"dim": []}, "Softmax": {"dim": [0.0, 1, 2, 10, 17, -2, null, -1]}, "Softmax2d": {}, "LogSoftmax": {"dim": [1, 2, -1, null, -2]}, "AdaptiveLogSoftmaxWithLoss": {"in_features": [null], "n_classes": [null], "cutoffs": [null], "div_value": [4.0, null], "head_bias": [true]}, "BatchNorm1d": {}, "BatchNorm2d": {}, "BatchNorm3d": {}, "GroupNorm": {"num_groups": [32, 1, 4, 8, null], "num_channels": [64, 32, null], "eps": [1e-05, 1e-08, null], "affine": [true, null]}, "SyncBatchNorm": {"num_features": [10, 4, null], "eps": [null], "momentum": [null], "affine": [null], "track_running_stats": [null], "process_group": [null]}, "InstanceNorm1d": {"num_features": [1, 10, null], "eps": [1e-05], "momentum": [0.0], "affine": [false, true], "track_running_stats": [false, true]}, "InstanceNorm2d": {"num_features": [512, 64, 32, 3, 1024, 1, 8, 10, null], "eps": [null], "momentum": [0, null], "affine": [false, true], "track_running_stats": [false, true]}, "InstanceNorm3d": {"num_features": [10, null], "eps": [], "momentum": [], "affine": [], "track_running_stats": [true]}, "LayerNorm": {"normalized_shape": [1024, 1, 0, null], "eps": [1, 4, "attn_layer_norm_1", 1e-12, null, 1e-06], "elementwise_affine": [false, null]}, "LocalResponseNorm": {"size": [256, 1, 5, 9, null], "alpha": [256, 0.0001, 1, null], "beta": [0.75, 0.5, null], "k": [0, 1, null]}, "RNNBase": {"mode": [null], "input_size": [], "hidden_size": [], "num_layers": [], "bias": [], "batch_first": [], "dropout": [], "bidirectional": []}, "RNN": {}, "GRU": {"input_size": [2048, 0, 32, 256, 4, 128, 3, 1, 10, null], "hidden_size": [64, 1, 2, 4, 7, 40, 10, null], "num_layers": [1, 2, 3, null]}, "RNNCell": {"input_size": [32, 2, 3, 4, 100, null], "hidden_size": [2, 3, 20, null], "bias": [null], "nonlinearity": ["relu", 5, null]}, "LSTMCell": {"input_size": [64, 0, 288, 1600, 1152, 256, 2, 1, 3, 1024, 100, 16, null], "hidden_size": [128, 512, 256, 2, 100, 32, 3, 51, 20, null], "bias": [false, true, null]}, "GRUCell": {"input_size": [64, 0, 2, 384, null], "hidden_size": [256, 2, null], "bias": [null]}, "Transformer": {"d_model": [0, 4, null], "nhead": [0, 2, 3, null], "num_encoder_layers": [0, 1, "tensorflow", null], "num_decoder_layers": [0, 1, null], "dim_feedforward": [8, null], "dropout": [null], "activation": [], "custom_encoder": [null], "custom_decoder": [null]}, "TransformerEncoder": {}, "TransformerDecoder": {}, "TransformerEncoderLayer": {}, "TransformerDecoderLayer": {}, "Identity": {}, "Bilinear": {"in1_features": [2, null], "in2_features": [3, null], "out_features": [1, 5, null], "bias": [false, null]}, "Dropout": {"p": [0.5, 0.2, 0.3, 0.25, 0.9, 0, 0.7, 0.75, 0.4, 0.6, 1.0, 0.35, 0.05, [0.0, 0.05], 0.1, 0.15, 0.8, "value", 0.02, 0.01, null], "inplace": [false, true, null]}, "Dropout2d": {"p": [0.1, 0.0, 0.175, 0.25, 0.2, 0.3, 0.05, 0.5, 0.8, 0.4, 0.19999999999999996, null], "inplace": [false, true, null]}, "Dropout3d": {"p": [null], "inplace": [false]}, "AlphaDropout": {"p": [0.05], "inplace": []}, "Embedding": {"num_embeddings": [0, 256, 1, 2, 1024, 5, 3, 257, 8, 10, 10000, 2708, 20, 26, 411720, 81, 100, 1000, null, "../github_crawler/torch_pyfiles"], "embedding_dim": ["", 1, 256, 3, 4, 512, 6, 128, 5, 8, 10, 2, 16, 1433, 32, 300, 50, 64, 200, 100, null], "padding_idx": [0, 1, 2, null, 25], "max_norm": [0, 1, 5, null], "norm_type": [null], "scale_grad_by_freq": [true, null], "sparse": [true, null], "_weight": [null]}, "EmbeddingBag": {"num_embeddings": [null], "embedding_dim": [null], "max_norm": [], "norm_type": [], "scale_grad_by_freq": [], "mode": [], "sparse": [true], "_weight": [], "include_last_offset": []}, "CosineSimilarity": {"dim": [0, 1, -1, null], "eps": [0, 1e-06]}, "PairwiseDistance": {"p": [1, 2, null], "eps": [], "keepdim": [true]}, "L1Loss": {"reduction": ["sum", null]}, "MSELoss": {"reduction": [false, "mean", "none", "sum", null, "elementwise_mean"]}, "CrossEntropyLoss": {"weight": [false, null], "ignore_index": [0, 1, null, -100, -1, 255], "reduction": ["mean", "sum", "none", null, "elementwise_mean"]}, "CTCLoss": {"blank": [null], "reduction": ["mean", "none", null], "zero_infinity": [true]}, "NLLLoss": {"weight": [null], "ignore_index": [0, -100, -1, null], "reduction": ["mean", "sum", "none", null]}, "PoissonNLLLoss": {"log_input": [], "full": [], "eps": [], "reduction": []}, "KLDivLoss": {"reduction": ["batchmean", "none", "sum", null], "log_target": []}, "BCELoss": {"weight": [null], "reduction": ["mean", "none", "sum", null, "elementwise_mean"]}, "BCEWithLogitsLoss": {"weight": [0, null], "reduction": ["mean", "sum", "none", null, "elementwise_mean"], "pos_weight": [0, null]}, "MarginRankingLoss": {"margin": [0.5, null], "reduction": []}, "HingeEmbeddingLoss": {"margin": [], "reduction": []}, "MultiLabelMarginLoss": {"reduction": []}, "SmoothL1Loss": {"reduction": ["sum", null]}, "SoftMarginLoss": {"reduction": []}, "MultiLabelSoftMarginLoss": {"weight": [null], "reduction": []}, "CosineEmbeddingLoss": {"margin": [], "reduction": ["mean"]}, "MultiMarginLoss": {"p": [1], "margin": [1.0], "weight": [0], "reduction": []}, "TripletMarginLoss": {"margin": [null], "p": [], "eps": [], "swap": [], "reduction": []}, "PixelShuffle": {"upscale_factor": [2, 4, null]}, "Upsample": {"size": [256, 512, 64, [1024, 2048], [19, 19], [299, 299], [505, 505], null], "scale_factor": [512, 32, 2, [2, 2, 2], 4, 3, 1, 8, 16, null], "mode": ["trilinear", "nearest", "bilinear", null], "align_corners": [false, true]}, "UpsamplingNearest2d": {"size": [], "scale_factor": [2, 3, null]}, "UpsamplingBilinear2d": {"size": [[513, 513], [224, 224], [321, 321], null], "scale_factor": [0, 32, 2, 8, null]}, "DataParallel": {}, "DistributedDataParallel": {}, "BasePruningMethod": {}, "PruningContainer": {}, "RandomUnstructured": {}, "L1Unstructured": {}, "RandomStructured": {}, "LnStructured": {}, "CustomFromMask": {}, "Flatten": {"start_dim": [0, 1, null], "end_dim": [null]}}